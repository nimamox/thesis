<!1,2015051712:31:40,V.2>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head><meta name="qrichtext" content="1" /><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><style type="text/css">
p, li { white-space: pre-wrap; }
</style></head><body>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\chapter{‏بررسی الگوریتم‌های ‎\lr{NUPACK}‏ ‏و ‎\lr{IncaRNAtion}‎‎‎‎‎}‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏در فصل قبل پس از معرفی مسئله پیش‌بینی پیچش معکوس ‎\lr{RNA}‎‏‏، روش‌هایی که برای حل این مسئله وجود دارند به صورت خلاصه ارائه شد. در این فصل دو روش از این روش‌ها بطور دقیق و با جزئیات مورد بحث و بررسی قرار خواهند گرفت. در ابتدا روش ارائه شده توسط زاده و همکاران ‎‎\cite{nupack}‎‎‏ یعنی ‎\lr{NUPACK}‎‏ ارائه می‌گردد و پس از آن روش راینهارز‎\footnote{\lr{Reinharz}}‎ و همکاران‎\cite{rein}‎‎‎‏ یعنی ‎\lr{IncaRNAtion}‎ به طور دقیق بررسی خواهد شد.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\section{\lr{NUPACK}}‎‎‎‏‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">همانطور که اشاره شد زاده و همکاران در سال 201‎0‎‎‎‎‏ روشی را برای حل مسئله پیش‌بینی معکوس پیچش ‎\lr{RNA}‎‏ ارائه دادند‏‎‎\cite{nupack}‎‎ و آن را ‎\lr{NUPACK‎‏} نامیدند‏. تفاوت اصلی این روش با روش‌های دیگر در این بود که این روش به جای تازدن توالی کاندید و محاسبه مقدار تفاوت ساختار با حداقل انرژی آزاد و ساختار هدف‏، آنها تابع تفکیک توالی کاندید را محاسبه می‌کردند و پس از آن مقدار خطای جمعی‎‎‎‏ را برای این توالی محاسبه کرده و به عنوان تابع برازندگی در نظر می‌گرفتند. در این قسمت به ارائه مرحله به مرحله این روش پرداخته خواهد شد.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\subsubsection*{‎‏تابع ‎‎‏هدف}‎‎</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">فرض کنید یک توالی ‎\lr{RNA}‎‏ با طول ‎$N‎$‎‏‎‏ به نام ‎$‎\phi‎$‎‏ ‎‏وجود‎‎‎ داشته باشد‏، همانطور که در فصل یک اشاره شد نمایش دایره‎‏‌ای ساختار دوم این توالی نوشتن نوکلئوتیدهای آن از سمت ‎$‎5'‎$‎‏ ‎‏به‎ سمت ‎$‎3'‎$‎‏‎‏ روی محیط یک دایره می‌باشد و ‏مانند تصویر ارائه شده در شکل ‎‎\ref{fig:314}‎‎ یک ساختار دوم بدون شبه گره صحیح وجود وترهایی از این دایره که بین جفت بازهای قابل پیوند‏(‎‎‎‎‎‎ ‎$‎A-U‎$‎‏‎‏‏، ‎$‎C-G‎$‎‏‎‏ و ‎$‎G-U‎$‎‏‎‏) که با یکدیگر برخورد نداشته باشند‏، است. مجموعه ‎$‎\Gamma‎‎$‎‏‎‏‏، مجموعه‌ای از تمامی ساختار دوم‌های صحیح می‌باشد که می‌تواند‎‎‎‎‎ روی ‎$‎\phi‎$‎‏‎‏ تشکیل شود. حال فرض کنید ‎$‎s‎$‎‏‎‏ یک ساختار صحیح روی ‎$‎\phi‎$‎‏‎‏ باشد(‎$‎s ‎\in ‎‎\Gamma‎‎ ‎$‎‏‏) مقدار ‎$‎‎\Delta ‎G(‎\phi‎,s)‎$‎‏‏ ‎که‎ روش محاسبه آن در بخش ‎‎\ref{sec:1.2} ‎‎‏ توضیح داده شد‏، برابر می‌شود با انرژی آزاد مربوط به ساختار ‎$‎s‎$‎‏‎‏ روی توالی ‎$\phi‎$‎‏‎‏ که با روش نزدیک‌ترین همسایه محاسبه شده است‎\cite{turner}‎.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\begin{figure}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\centering</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">{\footnotesize</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\includegraphics[height=8cm, width=8cm]{314}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\caption{‎‏یک ساختار دوم صحیح با نمایش دایره‌ای‎.}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\label{fig:314}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{figure}</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏زاده و همکاران‎‎\cite{nupack}‎ ‎‎‏برای ‎‏محاسبه‎ مقدار ‎$‎‎\Delta ‎G‎$‎‏‎ از پارامترهای روش نزدیکترین همسایه ترنر‎\footnote{\lr{Turner}}‎ 2004‎‎\cite{turner}‎‎‏ استفاده می‌کنند. به عنوان مثال این مقدار‏ برای ساختار و توالی مربوط به شکل ‎\ref{fig:318}‎ به روش زیر محاسبه می‌گردد.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\begin{latin}‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">{\footnotesize</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\begin{align*}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\Delta G_{37\,^{\circ}} &amp;= \Delta G_{37\,^{\circ}}(\text{Watson-Crick Pairs})+\Delta G_{37\,^{\circ}}(\text{Hairpin Loop})  \\</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\Delta G_{37\,^{\circ}} &amp;=  \Delta G_{37\,^{\circ}}(\text{Watson-Crick Pairs})+ \Delta G_{37\,^{\circ}}(\text{terminal mismatch})+\Delta G_{37\,^{\circ}\text{Hairpin initiation}}(6) \\‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\Delta G_{37\,^{\circ}}&amp;= \Delta G_{37\,^{\circ} }(\text{CG followed by AU})+\Delta G_{37\,^{\circ}}(\text{AU followed by CG}) + \Delta G_{37\,^{\circ} }(\text{CG followed by AU}) \\</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">&amp;+ \Delta G_{37\,^{\circ} \text{AU end penalty}}+\Delta G_{37\,^{\circ}}(\text{AU followed by AA}) + \Delta G_{37\,^{\circ}\text{Hairpin initiation}‎}(6) ‎\\‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\Delta G_{37\,^{\circ}}&amp;= -2.11 \text{kcal/mol}-2.24 \text{kcal/mol} -2.11 \text{kcal/mol} + 0.45 \text{kcal/mol} -0.8 \text{kcal/mol} +5.4 \text{kcal/mol} ‎\\‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\Delta G_{37\,^{\circ}}&amp;= -1.4 \text{kcal/mol}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{align*}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\end{latin}‎‎‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏مقادیر‎‎‏ انرژی مربوط به جفت‌بازهای متوالی (برای مثال {\footnotesize‎‎‏‎‎$\Delta G_{37\,^{\circ} }‎(\text{CG followed by AU})‎$‎‏})  در جدول‎‎\ref{tab:1.1}‎‎‏ به نمایش درآمده است. جداول باقی‎ مقادیر انرژی به دلیل تعداد زیاد و تنوع بالا قابل ارائه در این بخش نبوده اما از وب سرور ترنر‎‎\cite{turner}‎‎‏‎‎\footnote{\lr{http://rna.urmc.rochester.edu/NNDB}}‎‎‏ قابل دسترسی می‌باشند.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\begin{figure}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\centering</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">{\footnotesize</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\includegraphics[height=5cm, width=8cm]{318}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\caption{یک نمونه از ساختار و توالی آن برای محاسبه $\Delta G(\phi,s)$.}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\label{fig:318}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{figure}</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;"> تابع تفکیک الگوریتمی می‌باشد که انرژی تمامی ساختار‌های دوم ممکن برای یک توالی را در زمان ‎$‎O(n^3)‎$‎‏‎‏ محاسبه می‌کند‎‎\cite{landau}‎‎‏. این مقدار برای توالی ‎$\phi‎$‎‏‎‏ به صورت زیر محاسبه می‌گردد:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\begin{eqnarray}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">Q(\phi)=‎‎\sum‎‎_{s \in ‎\Gamma‎} e^{-‎\Delta ‎G(\phi,s)/k_B‎T}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{eqnarray}‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏‎که در آن ‎‎$‎k_B‎$‎‏‎‏ ثابت بولتزمن‎‎‏ و ‎$‎T‎$‎‏‎‏ دما می‌باشد. ‏حال با استفاده از تابع تفکیک میزان احتمال تعادلی‎‎\footnote{\lr{equilibrium probability}}‎‏‎ که نشان دهنده احتمال تا خوردن توالی ‎$‎‎\phi‎‎$‎‏ ‎‏به‎‎ ساختار ‎$‎s‎$‎‏‎‏ در میان تمامی ساختارهای ممکن برای آن است‏، برای هر ساختار مانند ‎$‎s‎$‎‏‎‏ به روش زیر محاسبه می‌گردد:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\begin{eqnarray}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">p(\phi,s)=‎\frac{1}{Q(\phi)}‎‎ ‎e^{-\Delta G(\phi,s)/k_BT}‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{eqnarray}‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏بدیهی است که ساختار با حداقل انرژی آزاد که از فرمول زیر بدست می‌آید بیشترین میزان احتمال را در میان ساختارهای ممکن به خو‏د اختصاص می‌دهد.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\begin{eqnarray}‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">s^{MFE}(\phi)=arg \min_{s\in ‎\Gamma‎} \Delta G(\phi,s)</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{eqnarray}‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏موضوع دیگری که باید به آن توجه گردد ماتریس احتمال جفت‌بازها‎‎\footnote{\lr{base-pairing probability matrix}}‎‎ ‏می‌باشد. این ماتریس ‎$‎N ‎‎\times ‎N‎$‎‏‎‏ بوده و هر سطر و ستون آن مربوط به یکی از نوکلئوتیدهای توالی ‎$\phi‎$‎‏‎‏ است. این ماتریس برای نشان دادن احتمال کلی جفت‌بازها ارائه شده به طوری که عنصر ‎$‎i,j‎$‎‏‎‏ این ماتریس نشان دهنده مجموع احتمال وجود جفت‌باز ‎$‎i-j‎$‎‏‎‏ برای تمامی ساختارهای ممکن روی توالی ‎$‎\phi‎$‎‏ ‎‏می‌باشد‎ و مقدار عناصر آن به روش زیر محاسبه می‌گردد:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\begin{eqnarray}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">P_{i,j}(\phi)=‎\sum‎_{s \in ‎\Gamma} ‎p(\phi,s)S_{i,j}(s)‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{eqnarray}‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏‎به طوری که در این فرمول ‎$‎S(s)‎$‎‏‎‏ ماتریس ‏وجود جفت‌بازهای ساختار ‎$‎s‎‎$‎‏‎‏ می‌باشد که عناصر آن به روش زیر محاسبه می‌شوند:</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\begin{eqnarray}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎S‎_{i,‎j}‎= \left\{</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\begin{array}{rl}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">1 &amp; \text{\lr{if    s contains pair i.j}}\\</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">0 &amp; \text{\lr{otherwiase} } </p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{array} \right.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{eqnarray}‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏مقدار فاصله دو ساختار را می‌توان به روش زیر محاسبه نمود:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\begin{eqnarray}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">d(s_1,s_2)=N-\sum_{1\leq i\leq N}\sum_{1\leq j\leq N+1} S_{i,j} (s_1)S_{i,j}(s_2)</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{eqnarray}‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏زاده و همکاران‎\cite{nupack}‎‎‎‏ همچنین مفهوم دیگری به نام ‎$‎‎‎\delta‎‎‎$‎‏‎‎‎‎‎‏ را بین دو ساختار مطرح کردند که ‏نشان دهنده برابر بودن یا نبودن دو ساختار است و با استفاده از فرمول زیر محاسبه می‌گردد:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\begin{eqnarray}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\text{‎$‎‎‎\delta‎_{‎(i,j)}‎$‎‏}‎= \left\{</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\begin{array}{rl}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">1 &amp; \text{\lr{if   ‎$‎‏d(s_1,s_2)=0‎$‎}}\\</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">0 &amp; \text{\lr{otherwiase} } </p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{array} \right.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{eqnarray}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏با توجه به روش‌های موجود مقادیر ساختار با حداقل انرژی و تابع تفکیک در زمان $O(n^3)$ قابل محاسبه می‌باشد‎‎\cite{hof}‎\cite{landau}‎‎‎‎‎‏. همچنین با داشتن تابع تفکیک ماتریس احتمال جفت‌بازها نیز در زمان ‎$‎O(n^3)‎$‎‏‎‏ قابل محاسبه است‎‎\cite{landau}‎‎.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">زاده‏ مسئله پیش‌بینی پیچش معکوس ‎\lr{RNA}‎‏ را به صورت یک مسئله بهینه سازی فرمول بندی کرد که در آن برای یک ساختار ‎‏ورودی مانند ‎$‎s‎$‎‏‎‏ الگوریتم به دنبال حداقل سازی یک تابع هدف ‎‏روی توالی کاندید ‎$‎\phi‎$‎‏‎‏ می‌باشد و زمانی که یک توالی یافت بشود بطوریکه مقدار تابع هدف روی آن از مقداری از پیش تعیین شده‌ یعنی شرط توقف‎‎\footnote{\lr{Prescribed stop condition}}‎‎ کمتر باشد‏، الگوریتم متوقف خواهد شد. او سه مقدار را به عنوان مقادیری که می‌توان به عنوان تابع هدف‎‎‎‎‎‎‎‎‎ در نظر گرفت به صورت زیر معرفی کرد:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\begin{enumerate}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\item‎‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏{\bf ‏بهینه‌سازی خطای ساختار با حد‎اقل انرژی آزاد:‎}‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏این روش که توسط اکثر محققین نیز به کار برده شده است سعی بر آن دارد تا فاصله ساختار ‎$‎s^{MFE}‎$‎‏‎‏ را با ساختار هدف کاهش دهد‏، در این روش مقدار تابع هدف برای یک توالی کاندید ‏مانند ‎$‎\phi‎$‎‏‎ با فرمول زیر محاسبه می‌گردد:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\begin{eqnarray}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\mu (\phi,s)=d(s^{MFE},s)=N-‎\‎sum_{1\leq i\leq N}\sum_{1\leq j\leq N+1} S_{i,j} (s^{MFE})S_{i,j}(s)‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\label{eq:1}‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{eqnarray}‎‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">در این فرمول ‎$‎s‎$‎‏‎‏ ساختار هدف بوده و ‎$S‎_{i,j}‎$‎‏‎‏ نشان دهنده وجود یا عدم وجود جفت باز ‎$‎i-j‎$‎‏‎‏ در ساختار هدف است. هرچه مقدار تابع هدف یک توالی کاندید عددی نزدیک تر به صفر باشد یعنی توالی کاندید مناسب‌تر است.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\item‎‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏{\bf ‏بهینه‌سازی خطای احتمالاتی:‎}‎‏ </p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">در این روش سعی می‌شود تا مقدار احتمال تا خوردن توالی کاندید را به ساختار هدف افزایش داد یعنی هرچه ساختار هدف در قسمت احتمالات تعادل‏، احتمال بیشتری را به خود اختصاص دهد‏، جواب بدست آمده بهتر می‌باشد. محاسبه تابع هدف در این روش به صورت زیر انجام می‌گیرد:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\begin{eqnarray}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\pi(\phi,s)=1-p(\phi,s)‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\label{eq:2}‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{eqnarray}‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\item‎‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏{\bf ‏بهینه‌سازی خطای جمعی‎}:‎‏‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">در روش سوم می‌بایست میانگین میزان جفت‌های غلط را در ‎‏ماتریس احتمال جفت‌بازها برای توالی کاندید کاهش داد که این روش با فرمول زیر محاسبه می‌گردد:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\begin{eqnarray}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">n(\phi,s)=\sum_{\sigma in ‎\Gamma‎} p(\phi,‎‎\sigma‎‎)d(‎‎\sigma‎‎,s)=N-\sum_{1\leq i\leq N}\sum_{1\leq j\leq N+1} P_{i,j}(\phi)S_{i,j}(s)‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\label{eq:3}‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{eqnarray}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{enumerate}‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏زاده و همکاران‎\cite{nupack}‎‎‎‏‏، ‎$‎n(\phi,s)‎$‎‏‎‏ را به عنوان تابع هدف در نظر گرفتند و هدف الگوریتم را کم کردن آن تا رسیدن به یک مقدار مورد نظر قرار دادند. به طوری که شرط توقف الگوریتم به صورت زیر است:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\begin{eqnarray}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">n(\phi,s)‎\leq ‎f_{stop}N‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{eqnarray}‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏که پارامتر ‎$‎f_{stop}‎$‎‏‎‏ مقداری در بازه ‎$‎[0,1]‎$‎‏‎‏ دارد و توسط کاربر تعیین می‌گردد.‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\subsubsection*{‏تجزیه ‎‎‏ساختاری}‎</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">زاده و همکاران‎‎‎\cite{nupack}‎ ساختار هدف را به صورت یک درخت دودویی تجزیه می‌کنند و برای هر نود روی  درخت با اندیس ‎$‎k‎$‎‏‎‎‏‏،‎‎‎ فرزند چپ را با ‎$‎k_‎\ell‎$‎‏‎‏ و فرزند راست را با ‎$‎k_r‎$‎‏‎‏ نشان می‌دهند. ساختار موجود در نود ‎$‎k‎$‎‏‎‏ را با ‎$‎s^k‎$‎‏‎‏ نشان داده و این ساختار میان فرزندان آن با شرایط زیر افراز می‌‌گردد.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\begin{eqnarray}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎s^k_\ell ‎‎‎\cap‎ ‎s^k_r = ‎‎‎\varnothing‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{eqnarray}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\begin{eqnarray}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">s^k_\ell \cup s^k_r = s^k</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{eqnarray}</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏‏در این دو فرمول ‎$‎s^k_‎\ell‎‎$‎‏‏ و ‎$‎s^k_‎r‎‎$‎‏‏ به ترتیب افراز چپ و افراز راست ساختار موجود در نود ‎$‎k‎$‎‏‎‏ یعنی ‎$‎s^k‎$‎‏‎‏ می‌باشند. همچنین‎‎‎‎ فرزندان هر نود قسمت اضافی را در محل شکسته شدن ساختار به ارث می‌برند که ‎‎$‎s^{k_\ell}_{dummy}‎$‎‏‎‏ نام دارد‎‎‎‏ و به طور پیش فرض دو جفت باز در نظر گرفته می‌شود‏. ‏این زیر ساختارهای جدید ‎$‎s^{k_\ell}‎$‎‏  و‎ ‎‎ ‎$‎s^{k_‎r‎}‎‎$‎‏‏ ‎‎نام دارند و تفاوت اصلی آنها با ساختارهای قبلی در این است که با یکدیگر دارای اشتراک می‌باشند‏، بطوریکه داریم:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\begin{eqnarray}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">s^{k_\ell}=s^{k_\ell}_{native} ‎\cup‎ s^{k_\ell}_{dummy} = s^k_{\ell +}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{eqnarray}‎‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\begin{eqnarray}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">s^{k_\ell} ‎‎\cap‎ s^{k_r} ‎=s^{k_\ell}_{dummy} \cup s^{k_r}_{dummy}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{eqnarray}</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">که در این فرمول ‎‎$‎s^{k_\ell}_{native}‎$‎‏‎‏ همان ساختار افراز شده یا ‎$‎s^k_\ell$‎‏‎‏ می‌باشد‏ و ‎$‎s^k_{\ell +‎}‎‎$‎‏‏ ساختار ‎‏نود‎ ‎$‎k_l‎$‎‏‎‏ ‎‎‎‎‎یعنی همان فرزند چپ نود ‎$‎k‎$‎‏‏‎ ‎است.‏ ‎برای‎ مثال در شکل ‎‎\ref{fig:315}‎‎ ‏نود موجود در سطح اول ‎$‎s^k‎$‎‏‎‏، نودهای پر رنگ‌تر در فرزند چپ آن ‎$s^k_‎\ell‎‎$‎‏‎‏‏، نودهای کمرنگ‌تر فرزند چپ $s^{k_\ell}_{dummy}$ و کل فرزند چپ ‎$‎s^{k_‎\ell}‎‎$‎‏ می‌باشند. دلیل تعریف $s^{k_\ell}$ ‏و ‎$‎s^k_‎\ell$‎‏ در بخش‌های بعدی اهمیت پیدا خواهد کرد. زیرا در هر گره از درخت تجزیه‏، یک توالی برای کل $s^{k_\ell}$‎‎‏ ساخته خواهد شد تا اشتراک ساختاری میان فرزندان چپ و راست یک گره وجود داشته باشد در قسمت تلفیق این توالی‌ها تنها توالی مربوط به ساختار $s^k_\ell$‏ و $s^k_‎r‎$‏ که با یکدیگر دارای اشتراک نیستند با یکدیگر ادغام می‌گردند.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">در روش زاده برخلاف روش‌های قبلی که ساختارها از حلقه‌های چندگانه می‌شکستند‏، ساختار هدف از استم‌ها شکسته می‌شود. این روش شکستن حالت عمومی‌تری دارد به‌طوری که برای ساختارهای بدون حلقه چندگانه نیز قابل اجرا می‌باشد. یک نقطه از استم‌های ساختار هدف در صورتی که پس از افراز در هر زیر ساختار حداقل به تعداد ‎$‎H_{split}‎$‎‏‎‏ جفت‌باز در همان استم و همچنین تعداد ‎$‎N_{split}‎$‎‏‎‏ نوکلئوتید در هر زیرساختار باقی بماند‏، یک نقطه قابل شکستن‎‎\footnote{\lr{Eligible Split-Point}}‎‎ خواهد بود‏. در صورتی که یک زیر ساختار هیچ نقطه قابل شکستنی نداشته باشد‏، در درخت تجزیه یک برگ خواهد بود و د‏ر صورتی که چندین نقطه وجود داشته باشد‏، نقطه‌ای برای افراز انتخاب می‌شود که تفاوت تعداد نوکلئوتیدهای دو زیر ساختار حداقل گردد. یک نمونه از شکستن ساختار توسط الگوریتم نوپک را می‌توان در شکل ‏‎‎\ref{fig:31}‎‎ مشاهده نمود.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\begin{figure}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\centering</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">{\footnotesize</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\includegraphics[height=4.5cm, width=8cm]{315}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\caption{تجزیه یک گره در درخت تجزیه الگوریتم \lr{NUPACK}.}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\label{fig:315}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{figure}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏برا‎ی ‏هر‎‎‎ نود مانند ‎$‎k‎$‎‏‎‏ با توالی ‎$‎\phi^k‎$‎‏‎‏ و ساختار ‎$‎s^k‎$‎‏‎‏ مقدار خطای جمعی ‎$‎n^k‎$‎‏‎‏ به صورت زیر محاسبه می‌گردد:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\begin{eqnarray}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">n^k=\sum_{1\leq i\leq |s^k|‎} ‎n^k_i‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{eqnarray}‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏که در آن ‎$‎n^k_i‎$‎‏‎‏ از روش زیر بدست می‌آید:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\begin{eqnarray}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">n^k_i=1-\sum_{1\leq j \leq |s^k|+1} P^k_{i,j}S^k_{i,j}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{eqnarray}‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏در این فرمول ‎‎$‎|s^‎k‎|‎$‎‏‎‏ تعداد نوکلئوتیدهای ساختار ‎$‎s^k‎$‎‏‎‏ می‌باشد و‏ همچنین $S^k_{i,j}‎$‎‏ و ‎$‎P^k_{i,‎j}‎‎$‎‏ ‏به ترتیب ماتریس وجود جفت‌بازها و ماتریس احتمال جفت‌بازها روی ساختار نود ‎$‎k‎$‎‏‎‏ هستند.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\begin{figure}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\centering</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">{\footnotesize</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\includegraphics[height=7cm, width=14cm]{31}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\caption{تجزیه ساختاری الگوریتم \lr{NUPACK}.}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\label{fig:31}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{figure}‎‎</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\subsubsection*{‎‏بهینه‌سازی ‎‎‏برگ‌ها}‎</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">طراحی توالی اولیه در الگوریتم نوپک به صورت تصادفی در برگ‌های درخت تجزیه انجام می‌گیرد. البته با وجود تصادفی انتخاب شدن نوکلئوتیدها‏، سازگار بودن توالی با ساختار هدف حفظ می‌شود‏، یعنی در قسمت‎هایی که در ساختار هدف جفت وجود دارد در توالی جفت‌بازهای واتسون-کریک قرار گیرد. پس از ساخت توالی اولیه جهش‌ها در برگ‌ها انجام می‌گیرد‏، این جهش می‌تواند روی یک نوکلئوتید صورت گیرد (در صورتی که ساختار هدف در آن موقعیت یک باز آزاد داشته باشد) و یا روی جفت‌باز انجام شود.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">انتخاب شدن یک نوکلئوتید برای جهش نسبت مستقیم با خطای آن نوکلئوتید دارد‏، یعنی احتمال انتخاب شدن نوکلئوتید شماره ‎$‎i‎$‎‏‎‏ برابر است با ‎$‎n^k_i/n^k‎$‎‏‎‏. با انجام جهشی که جزو لیست ‎$‎‎\gamma‎_{unfavorable}‎$‎‏‎‏ نیست ($\gamma_{unfavorable}$ لیست جهش‌های رد شده می‌باشد که در ابتدای هر مرحله خالی است و هر جهشی که امتحان شده نتیجه مناسبی نداشته باشد به آن اضافه می‌گردد) روی توالی فعلی (‎$‎\phi^k‎$‎‏‎‏) یک توالی کاندید (‎‎$‎‎\hat{\phi}^k‎$‎‏‎‏)‎ بدست می‌آید. پس از داشتن ‎$\hat{\phi}^k$‎‎‏ مقدار خطای جمعی آن ‎$‎‎\hat{‎n‎}^k‎$‎‏ ‎ ‎محاسبه‎ می‌گردد‏، این توالی در صورتی که میزان برازندگی را بهبود بخشیده باشد (‎$\hat{n}^k &lt; n^k$‎‏) حفظ می‌گردد و در غیر این صورت رد شده و به لیست $\gamma_{unfavorable}$ اضافه می‌گردد. لیست $\gamma_{unfavorable}$ پس از هر جهش پذیرفته شده به طور کامل پاک خواهد شد.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">بهینه سازی برای یک برگ تا زمانی که شرط زیر برقرار گردد‏، ادامه پیدا می‌کند.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\begin{eqnarray}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">n^k \leq f_{stop}|s^k|</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\label{eq:7}‎‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{eqnarray}‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏‎که در آن ‏‎$‎f_{‎stop}‎‎$‎‏ ‏ عددی بین صفر و یک است که کاربر می‌تواند با توجه به دقت مورد نیاز خود آن را تعیین نماید. پارامتر دیگری که در الگوریتم نوپک وجود دارد‎‎‎‎‎ ‎$‎M_{unfavorable}‎$‎‏‏ می‌باشد‏، در صورتی که در یک برگ در لیست $\gamma_{unfavorable}$ تعداد ‎$‎M|s^k|‎$‎‏‎‏ جهش قرار گیرد(‎$‎M‎$‎‏‎‏ نیز مانند ‎$‎f_{stop}‎$‎‏ ‎‏عددی‎ بین صفر و یک است که کاربر می‌تواند آن را تعیین نماید) و شرط بالا برقرار نگردد‏، بهینه‌سازی با یک توالی تصادفی دیگر دوباره از اول آغاز می‌گردد و اگر این شروع دوباه به تعداد ‎$‎M_{leafopt}‎$‎‏‎‏ بار صورت گیرد و بازهم شرط صحیح نشود‏، توالی با کمترین میزان خطای جمعی که در این چند اجرا دیده شده بود به عنوان توالی آن برگ در نظر گرفته می‌شود.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\subsubsection*{‎‏تلفیق ‎‎‏توالی‌ها}‎‎</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">پس از آنکه فرزندان یک نود مانند ‎$‎k‎$‎‏‎‏ جواب بهینه خود را یافتند‏، نود والد توالی‌های اصلی فرزندان چپ و راست خود را ادغام می‌کند.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\begin{eqnarray}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\phi^k= \phi^{k_l}_{native}.\phi^{k_l}_{native}‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\label{eq:6}‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{eqnarray}‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏که در این فرمول &quot;.&quot; نشان دهنده عملگر الحاق توالی می‌باشد. پس از بدست آوردن توالی‏، مقدار ‎$‎n^k‎$‎‏‎‏ محاسبه گشته و شرط مناسب بودن یک خطای جمعی برای یک نود والد به صورت زیر تعریف می‌گردد:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\begin{eqnarray}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">n^k\leq \text{max}(f_{stop}|s^k_l|,n^{k_l}_{native})+\text{max}(f_{stop}|s^k_r|,n^{k_r}_{native})</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{eqnarray}‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏اگر این شرط توقف برقرار گردد‏، توالی پذیرفته شده و آماده ارجاع به سطوح بالاتر درخت می‌گردد‏، در غیر این صورت یکی از زیرشاخه‌های نود ‎$‎k‎$‎‏‎‏ باید دوباره بهینه‎‌سازی گردد. فرزند چپ ‎$‎k‎$‎‏‎‏ با احتمال ‎$‎n^k_l/n^k‎$‎‏‎‏ و به همین ترتیب فرزند راست با احتمال $n^k_l/n^k$ انتخاب خواهند شد.  این انتخاب وابسته به خطای جمعی به صورت بازگشتی به سمت برگ‌های درخت در هر سطح انجام می‌گیرد تا مسیر به یک برگ برسد و در آن برگ دوباره روند بهینه سازی برگ‌ها با انتخاب یک توالی تصادفی جدید صورت خواهد گرفت و پس از یافتن توالی جدید برای آن برگ‏، دوباره توالی‌ها در همان مسیر بازگشته‏، سطح به سطح ادغام می‌شوند و شرط گفته شده برای هر سطح بررسی می‌گردد. در صورتی که دوباره در یک نود شرط برقرار نشد روند بازگشت به پایین برای آن نود انجام می‌گیرد. این روند برای هر نود حداکثر $M_{leafopt}$ بار انجام می‌گیرد و پس از آن‏، شرط برای آن نود نادیده گرفته شده و بهترین جواب موجود در آن نود به عنوان توالی آن نود در نظر گرفته می‌شود.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\subsubsection*{‎‏الگوریتم ‎\lr{NUPACK}‎}‎‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">به طور کلی اگر بخواهیم عملکرد الگوریتم نوپک را مرحله به مرحله توضیح دهیم به صورت زیر خواهد بود:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\begin{enumerate}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\item‎‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏در ابتدا الگوریتم نوپک ساختار هدف را به شکل یک درخت دودویی از استم‌های آن تجزیه می‌کند و این عمل تا جایی که دیگر زیر ساختارها شرایط تجزیه شدن را نداشته باشند ادامه پیدا می‌کند.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\item‎‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">روی برگ‌های این درخت تجزیه یک توالی کاندید تصادفی برای ساختار مربوط به آن برگ می‌سازد.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\item‎‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏با ‏اعمال جهش‌های وابسته به خطای نوکلئوتید روی توالی برگ‌ها و جستجوی محلی مقدار تابع هدف ارائه شده در فرمول ‎‎\ref{eq:3} ‎‏روی‎ توالی هر برگ را کاهش داده تا ‎‏مقدار ‏آن در معادله ‎‎\ref{eq:7}‎ صدق کند.‎‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\item‎‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏توالی ساخته شده برای برگ‌ها را با یکدیگر ادغام کرده به سطح بالاتر می‌آورد و میزان تابع هدف را روی زیر ساختار ادغام شده محاسبه می‌کند. اگر این میزان در معادله ‎‎\ref{eq:6} ‎‏صدق‎ نکند یکی از برگ‌ها به تصادف انتخاب شده و توالی جدیدی برای ساخته می‌شود و در غیر اینصورت این توالی به عنوان توالی کاندید برای زیر ساختار مربوط به آن نود در نظر گرفته می‌شود.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\item‎‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">عمل ادغام برای سطح به سطح به سمت ریشه ادامه می‌یابد تا در ریشه توالی برای کل ساختار ساخته شود.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{enumerate}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\subsection*{‎‏بررسی الگوریتم نوپک از لحاظ زمانی}‎‎‎‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏همانطور که اشاره شد خطای جمعی مربوط به توالی ‎$‎‎\phi‎‎$‎‏‎‏ از فرمول زیر محاسبه میگردد:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\begin{eqnarray}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">n(\phi,s)=\sum_{\sigma in \Gamma} p(\phi,\sigma)d(\sigma,s)=N-\sum_{1\leq i\leq N}\sum_{1\leq j\leq N+1} P_{i,j}(\phi)S_{i,j}(s)</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{eqnarray}</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">در صورت داشتن مقادیر ماتریس‌های ‎‎$‎P‎$‎‏‎‏ و ‎$‎S‎$‎‏‎‏ این فرمول مرتبه زمانی ‎$‎\theta‎(N^2)‎$‎‏‎‏ خواهد داشت. همچنین محاسبه ماتریس‌های  $P$ و $S$ ‏به ترتیب از مرتبه زمانی $\theta(N^3)‎$‎ و $‎\t‎heta(N^3)$‎‎ می‌باشند‎‎\cite{landau}‎‎‎‎‏‏، برای بررسی خطای یک توالی با طول ‎$‎N‎$‎‏‎‏ مرتبه زمانی به صورت زیر خواهد بود:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\begin{eqnarray}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">c_{eval}(N)=\theta(‎N^2+N^3+‎N^3)=\theta‎(N^3)</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{eqnarray}‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏با توجه به نوع تجزیه ساختار در الگوریتم نوپک در حالت ایده آل در هر سطح درخت ساختار به دو قسمت مساوی تقسیم می‌گردد. یعنی تعداد سطوح درخت ‎$‎\l‎g‎_2 ‎N‎‎$‎‏‎‏ خواهد بود و اندازه فرزندان هر نود به تعداد نصف نود والد می‌گردد. در بهترین شرایط برای هر برگ ‏توالی اولیه ساخته شده در شرایط آن برگ صدق خواهد کرد و تنها با یک بار محاسبه خطای جمعی‏، توالی مناسب برای برگ شناخته می‌گردد‏. یعنی زمان ساخت توالی مناسب برای یک برگ ‎$‎s^k‎$‎‏ در بهترین حالت  ($c_{eval}(|s^k|)$) خواهد بود. همچنین ‏اگر این اتفاق در هر نود غیر برگ نیز یکبار انجام گیرد. در این صورت برای زمان کلی بدست آوردن توالی کلی‏ (‎$‎c_{des}(N)‎$‎‏‎‏) داریم:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\begin{eqnarray}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">c_{des}(N)\geq c_{eval}(N)[1+2(‎\frac{1}{2})^3+4(\frac{1}{4})^3+8(\frac{1}{8})^3+‎\ldots‎]</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{eqnarray}‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">در این فرمول عدد ‎$‎2(\frac{1}{2})^‎3‎‎$‎‎‏‏ نشان دهنده زمان محاسبه سطح دوم درخت می‌باشد که در تجزیه ایده‌آل دو زیر ساختار با طول نصف ‎$‎N‎$‎‏‎‏ خواهیم داشت و به همین ترتیب با تجزیه ایده‌آل در سطح بعدی چهار زیر ساختار با طول یک چهارم ‎$‎‎N‎$‎‏‎‏‏، مقدار کلی فرمول بالا برابر می‌شود با:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\begin{eqnarray}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">c_{des}(N)\geq ‎\frac{4}{3}c‎_{eval}(N)</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{eqnarray}‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">البته به طور کلی در حالت معمولی عواملی چون نیاز به جهش‌های زیاد‏، بازگشت به سطوح پایین‌تر و عواملی از این دست باعث می‌شود زمان حالت میانگین الگوریتم بالاتر باشد ولی برای نشان دادن مرتبه زمانی الگوریتم نوپک می‌توان از ‎$‎\omega‎(N^3)‎$‎‏‎‏ استفاده نمود.‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\subsection{‏نتایج الگوریتم نوپک}‎</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">زاده و همکاران‎\cite{nupack}‎‎‎‏ پس از ساخت الگوریتم به بررسی نتایج بدست آمده توسط آن پرداختند. اولین موضوعی که مطرح بود در نظر گرفتن مقادیر پیش‌فرض برای پارامترهای الگوریتم بود. مقادیر پیش‌فرض ارائه شده توسط زاده در جدول ‎‎\ref{tab:31}‎‎(در مقاله ارائه شده توسط زاده و همکاران ‎‎\cite{nupack}‎‎‏ اشاره‌ای به چگونگی انتخاب مقادیر پیش‌فرض نشده است) به نمایش درآمده است.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;"> \begin{table}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">{\footnotesize</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\centering</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\begin{tabular}{p{6cm}  p{2cm} }</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\hline</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">{\bf ‎‎‏پارامتر} &amp; {\bf مقدار} ‎\\‎ \hline</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">{\bf ‎‎$‎H_{split}‎$‎‏‎} &amp; 2 \\</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">{\bf $N_{split}$} &amp; 20 \\‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">{\bf $f_{stop}$} &amp; 0.01 \\‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">{\bf $M_{reopt}$} &amp; 10 \\‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">{\bf $M_{leafopt}$} &amp; 3 \\‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">{\bf $M_{unfavorable}$} &amp; 4‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\\ ‎\hline‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{tabular}</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏\caption{‏پارامترهای ‎‎‏پیش‌فرض ‎‎‏روش زاده و همکاران‎\cite{nupack}‎‏.‎‎}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\label{tab:31}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{table}</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">زاده و همکاران‎\cite{nupack}‎ ‏در مقاله خود به آزمایش نتایج خود روی پایگاه‌های داده مشترک با روش‌های موجود دیگر نپرداختند و بجای این کار الگوریتم خود را با شرایط مختلف مثلا استفاده از جهش‌هایی با احتمال تصادفی یکنواخت و یا حذف کردن مرحله تجزیه ساختاری اجرا نموده و به ارائه نتایج آن پرداختند. ما در این قسمت از پایان‌نامه به ارائه نتایج موجود در مقاله الگوریتم نوپک‎‎\cite{nupack}‎‎‎‎‎‎‏ خواهیم پرداخت و در فصل بعدی نتایج آن را روی پایگاه داده‌های مشترک با روش‌های دیگر و همچنین روش ارائه شده در این پایان‌نامه مقایسه خواهیم کرد.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\subsubsection*{‎‏مجموعه ‎‏داده مورد آزمایش‎}‎‎</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">زاده و همکاران\cite{nupack}‎‏ پس از ارائه الگوریتم‏، برای بررسی عملکرد‏ آن دو مجموعه داده ساختند‏ که هرکدام از این مجموعه‌‌های داده‌ شامل 180 ساختار بود‏، بطوریکه در این مجموعه‌های داده برای هریک از طول‌های  ‎$‎n={‎100,200,400,800,1600,3200}‎$‎‏‏‏، ‎30‎ ساختار  در آن وجود داشت. ‎آنها‎ مجموعه داده اول را پایگاه‌داده مهندسی نامیدند‏، این پایگاه شامل نمونه ساختارهای تجربی مورد نیاز در علم مهندسی اسید نوکلئیک‎ ‏‎می‌باشد و مجموعه داده دوم یک پایگاه‌داده تصادفی بود که زاده و همکاران‎\cite{nupack} برای تولید آن‏،‏ توالی‌های تصادفی ‎\lr{RNA}‎‏ با طول‌های گفته شده تولید کرده و ساختار با حداقل انرژی این توالی‌ها را بدست آوردند‏، سپس این ساختارهای بدست آمده را به عنوان ساختارهای هدف در پایگاه‌داده تصادفی در نظر گرفتند.  اطلاعاتی در مورد مجموعه داده مهندسی و مجموعه داده تصادفی در شکل  ‎‎\ref{fig:32}‎‎ به نمایش درآمده است. در قسمت ‎$‎a‎$‎‏‎‏ این شکل نسبت تعداد جفت‌بازها به تعداد کل بازهای ساختار به نمایش درآمده است که در پایگاه داده تصادفی  ساختارهایی با نسبت نزدیک به ‎$‎0.6‎$‎‏‎‎ بیشترین تعداد را داشته‌اند ولی در پایگاه داده مهندسی این مقدار در حدود ‎$‎0.7‎$‎‏ ‎‏می‌باشد.‎ در قسمت ‎$‎b‎$‎‏ ‎‏تعداد‎ استم‌ها در ساختارها به نمایش درآمده‌اند که ساختارهای تصادفی به نسبت تعداد بیشتری استم را دارند و در قسمت ‎$‎c‎$‎‏‎‏ تعداد جفت‌بازهای موجود در استم به نمایش در آمده است که با توجه به شکل می‌توان دید که ساختارهای پایگاه داده تصادفی استم‌هایی کوتاه‌تر از پایگاه داده مهندسی داشته‌اند.‏ به طور عمومی می‌توان گفت مجموعه داده تصادفی دارای درصد کمتری از جفت‌بازها، تعداد بیشتری از استم‌ها و استم‌هایی با طول کمتر می‌باشد.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\begin{figure}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\centering</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">{\footnotesize</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\includegraphics[height=5cm, width=14cm]{32}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\caption{‎‏پایگاه‌های داده استفاده شده توسط زاده و همکاران ‎\cite{nupack}‎.}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\label{fig:32}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{figure}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\subsubsection*{عملکرد الگوریتم با شرایط پیش‌فرض}</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">نتایج عملکرد الگوریتم نوپک بر روی دو پایگاه داده مهندسی و تصادفی در شکل ‎‎\ref{fig:33}‎‎ به نمایش درآمده است. در این شکل نتایج مربوط به پایگاه داده مهندسی با دایره و نتایج مربوط به پایگاه داده تصادفی با مربع نمایش داده شده‌اند. همانطور در قسمت $a$ قابل مشاهده می‌باشد خطای جمعی جواب‌ها روی مجموعه داده مهندسی بهتر عملکرده و حتی با شرایط  نیز سازگار می‌باشد.  در قسمت $b$ نسبت زمان به طول ساختارها ارائه شده است که برای مثال برای حل ساختارهای مهندسی با طول 3200 نوکلئوتید به طور میانگین سه ساعت زمان صرف شده است.  در قسمت $c$ مقدار $‎C-G‎$ بدست آمده در توالی نهایی ارائه شده است همانطور که در شکل قابل مشاهده می‌باشد این مقدار وابستگی چندانی به طول توالی‌ها نشان نداده است به طور میانگین برای ساختارهای مهندسی حدود $\%60$ و برای ساختارهای تصادفی $\%50$ بوده است. همچنین باید در نظر گرفته شود که مقدار $G-C$ در توالی تصادفی اولیه برابر $\%50$ می‌باشد. در قسمت $d$ نیز نسبت $c_{des}(N)/c_{eval}(N)$ ارائه شده است که در حالت ایده آل این مقدار باید $4/3$ باشد. این مقدار در توالی‌هایی با طول پایین مناسب نبوده و این موضوع در داده‌های تصادفی شهود بیشتری نیز دارد‏، به طوری که برای داده‌های تصادفی با طول 100 مقدار ‎$‎c_{des}(N)‎$‎‏ ‏25 برابر $c_{des}(N)‎$‎‏ بوده است  اما هرچه طول توالی‌ها افزایش داشته این مقدار به حالت ایده‌ال نزدیک‌تر گردیده.‎‎</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\subsubsection*{‏شرایط ‎‏متفاوت جهش‌ها و تجزیه‎}‎</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\begin{figure}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\centering</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">{\footnotesize</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\includegraphics[height=12cm, width=14cm]{33}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\caption{نتایج الگوریتم نوپک با شرایط پیش‌فرض بر روی پایگاه‌های داده مهندسی و تصادفی.}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\label{fig:33}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{figure}</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">همانطور که در بخش معرفی الگوریتم مشاهده شد‏، الگوریتم نوپک به صورت پیش‌فرض ساختار را تجزیه می‌کند و همچنین احتمال انتخاب هر نوکلئوتید برای جهش متناسب با میزان خطای جمعی مربوط به آن نوکلئوتید بود. زاده و همکاران‎\cite{nupack}‎‏ این الگوریتم را به روش‌های دیگر پیاده سازی کردند تا نتایج بدست آمده توسط آنها را با روش پیش‌فرض مقایسه کنند. روش‌های دیگر ارائه شده به صورت زیر می‌باشند:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\begin{itemize}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\item‎‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏{\bf ‏بهینه‌سازی واحد با احتمال جهش یکنواخت‎‎\footnote{\lr{Single-scale ensemble defect optimization with uniform mutation</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏sampling}}‎‎:‎}‎‏ ‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏در این روش تجزیه توالی وجود ندارد و بهینه سازی ارائه شده در برگ‌ها برای کل توالی به صورت واحد استفاده می‌گردد. همچنین احتمال جهش برای تمامی نوکلئوتیدها برابر می‌باشد.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\item‎‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏{\bf ‏‎بهینه‌سازی واحد با جهش وابسته به خطا‎‎\footnote{\lr{Single-scale ensemble defect optimization with defect-weighted</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏mutation sampling}}‎‎: }‎‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏در این روش نیز بهینه‌سازی برروی کل توالی انجام می‌گیرد ولی احتمال جهش‌ها مانند روش پیش‌فرض نسبت مستقیم با خطای جمعی آن نوکلئوتید خواهد داشت.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\item‎‎‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏{\bf ‏بهینه‌سازی سلسله مراتبی با احتمال جهش یکنواخت‎‎\footnote{\lr{Hierarchical ensemble defect optimization with uniform samplin‎‏g}}‎‎: ‎}‎‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏این‎‎ روش ساختار را روی درخت تجزیه کرده و بهینه‌سازی روی برگ‌ها انجام می‌گیرد اما احتمال جهش نوکلئوتیدهای هر برگ با یکدیگر برابر می‌باشد.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{itemize}</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">نتایج بدست آمده توسط این چهار روش اجرا بر روی پایگاه داده مهندسی در شکل ‎‎\ref{fig:34}‎‎ به نمایش درآمده است. همانطور در قسمت $a$ قابل مشاهده می‌باشد هر چهار روش به نتیجه رسیده‌اند ولی خطای جمعی الگوریتم‌هایی که ساختار را تجزیه می‌کنند در پایان مناسبتر است. الگوریتم با تجزیه ساختار و جهش‌های یکنواخت بهترین عملکرد در این قسمت را داشته است.  در قسمت $b$ نسبت زمان به طول ساختارها ارائه شده است که در این قسمت نیز طبق انتظار  الگوریتم‌هایی که ساختار را تجزیه می‌کنند عملکرد بهتری را نشان داده‌اند و در اکثر موارد در زمان کمتری به جواب دست یافته‌اند.  در قسمت $c$ مقدار $C-G$ بدست آمده در توالی نهایی ارائه شده است که با توجه به آن می‌توان نتیجه گرفت مقدار $C-G$ جواب نهایی به نوع جهش‌ها وابسته می‌باشد به طوری که در الگوریتم‌هایی که از جهش‌های یکنواخت استفاده می‌کنند این مقدار به عدد یک نزدیک تر می‌باشد ولی در الگوریتم‌هایی که از جهش‌هایی با احتمال وابسته به خطا استفاده می‌کنند این مقدار به عدد ‎$‎0.5$‎‏ ‎‏یا‎‎ همان مقدار اولیه نزدیکتر است. در قسمت $d$ نیز نسبت $c_{des}(N)/c_{eval}(N)$ ارائه شده است که این مقدار در الگوریتم‌هایی که ساختار را تجزیه نمی‌کنند با افزایش طول بدتر شده است ولی در الگوریتم‌های دیگر به افزایش طول به خط ایده‌آل نزدیکتر گردیده است در این قسمت نیز مانند قسمت زمان اجرا الگوریتم نوپک با شرایط پیش فرض بهترین عملکرد را داشته است.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\begin{figure}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\centering</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">{\footnotesize</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\includegraphics[height=12cm, width=14cm]{34}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\caption{نتایج الگوریتم نوپک روی پایگاه‌داده مهندسی با شرایط مختلف اجرا .}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\label{fig:34}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{figure}</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\subsubsection*{‎‏ساخت ‎‎‏توالی اولیه}‎‎</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏زاده و همکاران برای بررسی عملکرد الگوریتم خود با روش‌های مختلف ساخت توالی اولیه‏، چهار روش متفاوت را برای این کار در نظر گرفتند.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\begin{itemize}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\item‎‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏توالی تصادفی(پیش‌فرض)</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\item‎‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">توالی‎ تصادفی تنها با جفت‌بازهای ‎‎$‎A-T‎$‎‏‎‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\item‎‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏توالی تصادفی تنها با جفت بازهای ‎$‎C-G‎$‎‏‎‏‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\item‎‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">توالی‎ با حداقل‌سازی شباهت توالی‎‎\footnote{\lr{sequence symmetry minimization}}‎‎‎‏:</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">این روش مکاشفه‌ای می‌باشد که از ایجاد زیرتوالی‌های مشابه با طول از پیش مشخص شده(در الگوریتم زاده‏، شش نوکلئوتید) در قسمت‌های مربوط به جفت‌بازها و بازهای آزاد ساختار هدف جلوگیری می‌کند.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{itemize}</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">نتایج بدست آمده روی پایگاه داده مهندسی که در شکل ‎‎\ref{fig:35}‎‎ ارائه شده‌اند‏، نشان داد که روش ساختن توالی اولیه تاثیری در میزان خطای جمعی نهایی نداشته است به طوری که خطای جمعی نهایی برای هر چهار مورد بسیار نزدیک بهم می‌باشد(قسمت ‎‎$‎a‎$‎‏‎‏) و تاثیر کمی در زمان رسیدن به ‎‏جواب داشته و تنها زمان رسیدن به جواب برای قسمت توالی تصادفی تنها با جفت بازهای $C-G$ کمی طولانی‌تر از قسمت‌های دیگر می‌باشد (قسمت ‎$‎b‎$‎‏‎‏ و ‎$‎d‎$‎‏‎‏) ‎‎‏ولی توالی‌هایی که با جفت‌بازهای ‎$‎C-G‎$‎‏‎‏ یا ‎$‎A-U‎$‎‏‎‏ آغاز گردیده‌اند به طور کاملا مشهود مقدار ‎$‎C-G‎$‎‏‎های متفاوتی را در پایان داشته‌اند که این موضوع می‌تواند در زمانی که نیاز به توالی‌هایی با مقدار ‎$‎C-G‎$‎‏‏ نزدیک به یک و یا با مقدار ‎$‎C-G‎$‎‏‎‎‎‏ کمتر از ‎$‎0.5‎$‎‏‎‏ است‏، مورد استفاده قرار گیرد‎(قسمت ‎$‎c‎$‎‏‎‏).</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\begin{figure}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\centering</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">{\footnotesize</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\includegraphics[height=12cm, width=14cm]{35}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\caption{نتایج الگوریتم نوپک روی پایگاه‌داده مهندسی با دنباله اولیه‌های متفاوت.}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\label{fig:35}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{figure}</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\subsubsection*{‎‏بررسی تابع برازندگی‌های متفاوت}‎‎</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏‎موضوع دیگری که زاده و همکاران‎\cite{nupack}‎‏ به بررسی آن پرداخته‌اند استفاده از خطاهای دیگر بجای خطای جمعی‏، به عنوان تابع برازندگی بود. از این رو در دو الگوریتم متفاوت خطای احتمالی ‏‎$‎\pi ‎(\phi,s)‎$‎‏‎‏ که در فرمول ‎(‎‎‎\ref{eq:2})‎‎‎‏ ارائه گردید‏‏‎‎‎‎ و همچنین‎‎ خطای مربوط به ساختار با حداقل انرژی که به صورت ‎$‎\mu ‎(\phi,s)‎$‎‏‎‏ نشان داده شده و مقدار آن از فرمول ‎‎(\ref{eq:1}) ‏ ‎‎بدست‎ می‌آید‏،  را به عنوان معیار در نظر گرفتند که نتایج بدست آمده توسط این سه روش روی پایگاه‌داده مهندسی در شکل ‎\ref{fig:36}‎ به نمایش درآمده است. ‏در قسمت ‎$‎a‎$‎‏‎‏ خطای جمعی جواب نهایی ارائه شده است که عملکرد الگوریتم استفاده کننده از ساختار با حداقل انرژی در این قسمت مناسب نمی‌باشد. در قسمت ‎‎$‎b‎$‎ و ‎$‎d‎$‎‏‎‎‎ ‏مقدار زمان اجرا و نسبت آن به مقدار ایده‌آل ارائه شده است که در این قسمت‏‎‎‎‎‎‎‎‏ بهترین زمان را  الگوریتم استفاده کننده از ساختار با حداقل انرژی داشته و پس از آن الگوریتم نوپک با شرایط پیش فرض اما الگوریتم‌هایی که ساختار را تجزیه نمی‌کنند از لحاظ زمانی بسیار نا مناسب عمل می‌کنند. در قسمت ‎$‎c‎$‎‏‎‎‏ نیز مقدار ‎$‎C-G‎$‎‏ ‎‏نهایی‎ به ارائه در آمده است که دو الگوریتمی که از لحاظ زمانی عملکرد مناسبتری را داشته‎‌اند تغییرات چندانی را در مقدار ‎$‎C-G‎$‎‏ ‎‏اولیه‎ ایجاد نکرده‌اند. اما دو روش دیگر با جهش‌های زیاد اکثر جفت‌بازها را به ‎$‎C-G‎$‎‎‎‎‏ تغییر داده به طوری که مقدار ‎$‎C-G‎$‎‏ ‎‏نهایی‎ آنها برای طول‌های بیش از 500 نوکلئوتید از ‎$‎0.8‎$‎‏‎ ‎‏فراتر رفته و عددی نزدیک به یک می‌باشد.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\begin{figure}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\centering</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">{\footnotesize</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\includegraphics[height=12cm, width=14cm]{36}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\caption{نتایج الگوریتم نوپک روی پایگاه‌داده مهندسی با تابع برازندگی‌های متفاوت.}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\label{fig:36}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{figure}‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\section{‏الگوریتم ‎\lr{incaRNAtion}‎}‎‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">در این بخش به ارائه الگوریتم ‎\lr{IncaRNAtion}‎‏ ارائه خواهد شد که یک الگوریتم نمونه سازی وزن‌دار برای یک ساختار هدف\footnote{\lr{Weighted sampling algorithm for the design of RNA}} می‌باشد. ‏راینهارز و همکاران‎\cite{global}‎‎‎‏ در سال 2008 الگوریتمی برای نمونه‌سازی سراسری\footnote{\lr{Global sampling algorithm for the design of RNA}} برای یک ساختار هدف با نام ‎\lr{RNA‎-ensign‏} ارائه داده بودند که \lr{IncaRNAtion}  مدل توسعه یافته آن می‌باشد‏. به همین دلیل در این بخش ابتدا به ارائه ‎\lr{RNA-ensign}‎‏ پرداخته خواهد شد و پس از آن \lr{IncaRNAtion}  به تفصیل توضیح داده می‌شود. </p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\subsection{معرفی الگوریتم \lr{RNA-ensign}}‎</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">همانطور که اشاره شد \lr{RNA-ensign} یک الگوریتم برای نمونه سازی‏ وزن دار ساختار هدف ‎‏است‏، به طوری که ورودی آن یک ساختار هدف و خروجی آن تعدادی توالی که با ساختار هدف در تضاد نباشند (در موقعیت‌های متناظر با قسمت‌های جفت شده ساختار هدف‏، جفت بازهای واتسون-کریک یا وابل قرار داشته باشد) و هدف ‎‏این‎ الگوریتم بالا بردن احتمال تعادلی ساختار هدف در این مجموعه نمونه است.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">در الگوریتم \lr{RNA-ensign} از یک نوع جهش به نام ‎\lr{‎$‎k‎$‎‏-mutants}‎‏ استفاده شده است. این جهش در سال 2008 توسط ‏ولدیسفو‎‎\footnote{\lr{Waldispu}}‎‎ و همکاران‎\cite{wald}‎‎‎‏ در الگوریتم ‎\lr{RNAmutants}‎‏ ارائه شده بود.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\begin{figure}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\centering</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">{\footnotesize</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\includegraphics[height=19cm, width=17cm]{37}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\caption{‎‎‏‌نمونه‌ای از کارکرد الگوریتم ‎\lr{RNAmutants}‎.}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\label{fig:37}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{figure}</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">الگوریتم \lr{RNAmutants} یک روش می‌باشد که با گرفتن توالی ‎\lr{RNA}‎‏ به عنوان ورودی‏‏، در زمان چندجمله‌ای‏، میزان تابع تفکیک بولتزمن همسایه‌هایی از این توالی ‎‎‏را که دقیقا در ‎‎$‎k‎$‎‏‎‏ نقطه از نوکلئوتیدها با آن تفاوت دارند محاسبه می‌کند. مقدار ‎‎$‎k‎$‎‏‎‏ در این توالی می‌تواند بین صفر تا ‎‎$‎n‎$‎‏ (طول توالی ورودی) تغییر کند. کلیت کار الگوریتم \lr{RNAmutants} در شکل ‎\ref{fig:37}‎ به نمایش درآمده است. همانطور که مشاهده می‌کنید در این شکل یک توالی اولیه به صورت ‎\lr{AGACCAAACUCU}‎ موجود می‌باشد و الگوریتم ساختارهای ممکن برای‏ همسایه‌هایی از این توالی که در یک یا دو نقطه از نوکلئوتیدها با آن متفاوت می‌باشند (‎$‎k\in ‎\{1 , ‎‎2\}‎$‎‏)‎‎‏ بدست آورده است ‏که نمونه‌هایی از ساختارهای ممکن برای خود این توالی و برخی از همسایه‌های آن به نمایش درآمده است.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">فرض کنید ‎$‎S^*‎$‎‏‎‏ یک ساختار هدف ‏ورودی در‎‎ الگوریتم \lr{RNA-ensign‏} باشد که طول آن برابر با ‎$‎n‎$‎‏‎‏ است. ‎$‎w=‎\{w_1,w_2,‎\ldots‎,w_n\}‎$‎‏‎‏ مجموعه‌ای از توالی‌ها خواهد بود که با ساختار هدف در تضاد نیستند. میزان احتمال مربوط به ‎$‎i‎$‎‏‎‏امین توالی از توالی‌های مجموعه ‎$‎w‎$‎‏‎‏، از فرمول زیر محاسبه می‌گردد:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\begin{eqnarray}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">p(w_i)=e^{-‎E(w_i)‎/RT}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{eqnarray}‎‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">که در آن ‎$‎E(w_i)$‎‏‎‏ مقدار انرژی ‎$‎w_i‎$‎‏‎‏ وقتی به صورت ساختار ‎$‎S^*‎$‎‏‎‏ تا بخورد است. ‎$‎R‎$‎‏‎‏ ثابت گازها و ‎$‎T‎$‎‏‎‏ دما می‌باشد. میزان برازندگی جواب ‎$‎w‎$‎‏‎‏ برابر است با مجموع احتمال توالی‌های موجود در آن‏، یعنی: </p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\begin{eqnarray}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">Fitness(w)=\sum_i p(w_i)</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{eqnarray}‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏الگوریتم ‎\lr{RNA-ensign}‎‏ به این صورت عمل می‌کند که یک توالی تصادفی را به عنوان توالی اولیه می‌سازد و تعدادی ‎\lr{R-mutants}‎‏ را با مقادیر مختلف ‎$‎k‎$‎‏‎‏ روی آن اعمال می‌کند. این جهش‌ها می‌توانند به صورت تصادفی یکنواخت یا وابسته به برازندگی هر نوکلئوتید در تابع تفکیک انتخاب شوند. نمودار تاثیر نوع انتخاب جهش‌ها در شکل ‎‎\ref{fig:38}‎‎ به نمایش درآمده است. ‏محور افقی نمودار تعداد جهش‌ها یا همان عدد ‎$‎k‎$‎‏‏ و محور عمودی آن میزان احتمال ساختار هدف می‌باشد که عددی بین صفر و یک بوده و هرچه این عدد به یک نزدیکتر باشد نشان دهنده نتیجه مناسبتری است. ‎‎‏همانطور ‎‏که در این شکل قابل مشاهده می‌باشد‏، جهش‌هایی که بر اساس میزان برازندگی نوکلئوتیدها انجام شده‌اند و با دایره به نمایش درآمده‌اند عملکرد بهتری داشته و با افزایش تعداد این جهش‌ها‎‏‏، احتمال ساختار هدف نیز به یک نزدیکتر شده است‎‎. همچنین در شکل ‎\ref{fig:38}‎ ‏، علامت ‎\lr{‎(‎MFE)}‎‏ که با مثلث و دایره‌های بزرگ به نمایش درآمده است‏، نشان دهنده توالی‌هایی می‌باشد که ساختار با حداقل انرژی آنها معادل با ساختار هدف می‌باشد.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\begin{figure}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\centering</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">{\footnotesize</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\includegraphics[height=9cm, width=12cm]{38}</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏\caption{‌‎‏عملکرد روش ‎\lr{RNA-ensign}‏ با جهش‌های یکنواخت و غیر یکنواخت‎‎.}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\label{fig:38}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{figure}</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">در الگوریتم ‎\lr{RNA-ensign}‎‏ پس از اجرای ‎\lr{k-mutants}‎‏ با مقادیر مختلف ‎$‎k‎$‎‏‎‏ روی توالی اولیه یک پروسه انجام می‌گیرد و همسان بودن ساختار با حداقل انرژی توالی‌های بدست آمده را با ساختار هدف بررسی می‌کند و اگر برای یک مقدار ‎$‎k‎$‎‏‎‏ چندین جواب وجود داشت‏، توالی‌ای که بیشترین میزان احتمال ‎$‎p‎$‎‏‎‏ را داشته باشد‏، برای آن ‎$‎k‎$‎‏‎‏ در نظر می‌گیرد و در صورتی که برای یک مقدار ‎$‎k‎$‎‏‎‏ ساختاری معادل با ساختار هدف وجود نداشته باشد‏، نزدیکترین ساختار را برای آنها در نظر می‌گیرد.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">با تکرار این عمل در پایان مجموعه‌ای از توالی‌ها وجود خواهد داشت که همه آنها می‌توانند به ساختار هدف تا بخورند و همچنین احتمال ساختار هدف در تابع تفکیک آنها زیاد می‌باشد.‎ یکی از معایب الگوریتم \lr{RNA-ensign} زمان اجرای آن است‏، به طوری که این الگوریتم پیچیدگی محاسباتی از مرتبه ‎$‎O(n^5)‎$‎‏‎‏ دارد و در مقاله آن گفته شده است که برای ساختارهایی با طول بیشتر از دویست نوکلئوتید بسیار زمانبر خواهد بود.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\subsection{‏معرفی ‎‏الگوریتم ‎\lr{IncaRNAtion}‎‎}‎‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏همانطور که در بخش قبلی اشاره شد الگوریتم ‎\lr{RNA-ensign}‎‏ در زمان ‎$‎O(n^5)‎$‎‏‎‏ انجام می‌گرفت و به همین دلیل برای ساختارهای با طول بالا مناسب نبود‏، از این رو راینهارز و همکاران‎\cite{rein}‎‎‎‏ با فرمول‌بندی جدید‏، الگوریتم ‎\lr{IncaRNAtion}‎‏ ‏را ارائه نمودند که در زمان خطی نسبت به ورودی انجام می‌گیرد و همچنین کاربر می‌تواند مقدار ‎$‎C-G‎$‎‏‎‏ مورد نظر را برای توالی‌های نمونه تعیین نماید.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">راینهارز و همکاران‎\cite{rein}‎‎‎‏ برای ساده سازی مدل خود از نوعی تابع محاسبه انرژی آزاد استفاده نمودند که تنها خاصیت پشته‌ای جفت‌بازها را در نظر می‌گرفت. این تابع انرژی برای جفت‌بازهای پشته‌ای از مقادیر ارائه شده در ترنر‎‎‎‎\cite{turner}‎‎‎ 201‎0 ‏‎ استفاده می‌نماید‏. ‎‎‏مقادیر انرژی ترنر 2010 برای ‎‏جفت‌بازهای‎‎ پشته‌ای در جدول ‎‎\ref{tab:1.1}‏‎‎ به نمایش در آمده‌اند. یعنی اگر یک توالی کاندید مانند ‎$‎s‎$‎‏‎‏ روی ساختار دوم ‎$‎S‎$‎‏‎‏ وجود داشته باشد‏، مقدار انرژی توای ‎$‎s‎$‎‏‎‏ وقتی به این ساختار تا بخورد به صورت زیر محاسبه می‌گردد: </p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\begin{eqnarray}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">E(s,S)=\sum_{(i,j)\to (i',j') \in S} E^\beta_{s_is_j\to s_{i'}s_{j'}}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{eqnarray}‎‎‎‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">به طوری که ‎$‎E^\beta_{‎ab‎\to a'b'‏}‎$‎‏ برابر صفر خواهد بود اگر ‎$ab=\varnothing‎‎$‎‏‏ (یعنی جفت‌بازی برای ساخت پشته وجود نداشته باشد) و در غیر این صورت از درایه ‎$‎(ab)/(a'b')‎$‎‏ ‎‏جدول‎‎ ترنر(جدول ‎‎\ref{tab:1.1}‎‎‏) بدست می‌آید. در صورتی که مقدار جدول ترنر در درایه $(ab)/(a'b')$ به صورت ‎$‎''-''‎$‎‏‎‏ باشد‏، خواهیم داشت:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\begin{eqnarray}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">E^\beta_{ab\to a'b'}=‎\beta‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{eqnarray}</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏در‎‎‎ این فرمول  ‎$‎‎\beta ‎\in ‎[0,‎\infty‎]‎$‎‏‎‏ ‎‏یک ‎‏پارامتر ورودی مسئله ‎‎‏می‌باشد که کاربر می‌تواند آن را تعیین نماید و برای جریمه جفت‌بازهای غیر واتسون-کریک/ ‎‎‏وابل‎‎ در نظر گرفته شده است. با قرار دادن ‎$‎‎\beta‎=+‎\infty‎‎$‎‏‎‏ وجود آنها غیر معتبر می‌گردد و یا می‌توان برای آنها جریمه‌ای مثبت در نظر گرفت‏، که این موضوع قابل انتخاب توسط کاربر می‌باشد.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">پارامتر دیگری که در الگوریتم راینهارز مطرح است‏، مقدار ‎$‎x\in [0,\infty]‎$‎‏‎‏ است که وزن و میزان تاثیر مقدار ‎$‎C-G‎$‎‏‎‏ در یک توالی تولید شده را تنظیم می‌کند. برای ‎‎‎‏هر ساختار دوم مانند ‎$‎S‎$‎‏‎‏‏، فاکتور وزن‌دار ‎$‎C-G‎$‎‏‏‎‎‎‎\footnote{\lr{CG-weighted-Boltzman factor}}‎‎  بولتزمن ‏روی توالی ‎$‎s‎$‎‏‎‏ با ‎$\mathcal{B}^{(x)}_S(s)‎$‎‏‎‏ نمایش داده شده و به صورت زیر محاسبه می‌گردد:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\begin{eqnarray}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\mathcal{B}‎^{(x)}_S(s)=e^{‎\frac{-E(s,S)}{RT}‎}.x^{\# gc(s)}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{eqnarray}‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏‎که در آن ‎$‎\‎#‎gc(s)‎$‎‏‎‏ تعداد جفت‌بازهای ‎$‎C-G‎$‎‏‏‏، ‎‎$‎R‎$‎‏‎‏ ثابت بولتزمن و ‎$‎T‎$‎‏‎‏ دما می‌باشد. تابع تفکیک وزن‏دار‎ ‎$‎C-G‎$‎‏‎ ‎‎\footnote{\lr{‎‏‎CG-weighted parttion function‎}}‎  ‎‏برابر‎ با مجموع فاکتور وزن‌دار بولتزمن برای تمامی توالی‌های ممکن روی ساختار ‎$‎S‎$‎‏‎‏ می‌باشد:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎‎\begin{eqnarray}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">Z^{[x]}_S=\sum_{|s|=n}\mathcal{B}^{[x]}_S(s)</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\label{eq:4}‎‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{eqnarray}‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏‎در این فرمول نماد ‎$‎[x]‎$‎‏‎‏ نشان دهنده در نظر گرفته شدن مقدار ‎$‎G-C‎$‎‏‎‏ در محاسبه تابع تفکیک با ضریب ‎$‎x‎$‎‏ ‎‏می‌باشد.‎‎‎‎‎‎ به همین ترتیب احتمال وزن‌دار بولتزمن‎‎\footnote{\lr{CG-weighted Boltzman probability}}‎‏‎ توالی ‎$‎s‎$‎‏‎‏ از فرمول زیر محاسبه می‌گردد:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\begin{eqnarray}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">p^{[x]}_S(s)=‎\frac{\mathcal{B}^{[x]}_S(s)}{Z^{[x]}_S}‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\label{eq:5}‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{eqnarray}‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‏‎</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏الگوریتم ارائه شده توسط راینهارز و همکارا‎ن\cite{rein}‎ ‏شامل دو مرحله می‌باشد که در مرحله اول توسط یک برنامه پویا تابع تفکیک تمامی زیرساختارهای ممکن برای ساختار هدف محاسبه و ذخیره می‌گردد و در مرحله دوم با چندین بار عمل بازگشت به عقب تصادفی ‎‎\footnote{\lr{Stochastic back trace}}‎‏‎ توالی‌های مختلفی با مقدار ‎$‎C-G‎$‎‏‏‎ مناسب را می‌یابد.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\subsubsection*{‏محاسبه تابع تفکیک وزن‌دار}‎</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">همانطور که گفته شد در مرحله آغازین یک الگوریتم پویا اقدام به محاسبه ‎‎$‎Z^{[a,b]}_{N,S}‎$‎‏‎‏ می‌کند.  $Z^{[a,b]}_{N,S}$ همان تابع تفکیک وزن دار $C-G$ ارائه شده در فرمول \ref{eq:4} می‌باشد که مجموع انرژی تمامی توالی‌های ممکن برای یک ساختار را محاسبه می‌کند اما در این بخش نوع اندیس گذاری آن به منظور ارائه بهتر جزئیات ساختار تغییر نموده است. در این اندیس گذاری جدید‎‎‎ ‏اندیس ‎$‎[x]‎$‎‏‎‏ به منظور جلوگیری از تعدد اندیس‌ها حذف شده است اما همچنان به عنوان یک پارامتر ورودی وجود خواهد داشت و اندیس‌های دیگر نیز نشان دهنده تابع تفکیک وزن ‌دار زیرساختار $S$ می‌باشند که با موقعیت‌های ‎‎$‎a‎$‎‏‎‏ و ‎$‎b‎$‎‏‎‏ احاطه شده است( یعنی موقعیت‌های ‎$‎a‎$‎‏‎‏ و ‎$‎b‎$‎‏‎‏ خارج از ساختار ‎$‎S‎$‎‏‎‏ و مجاور با آن می‌باشند)‏. متغیر ‎$‎T‎$‎‏‎‏ نشان دهنده وجود یا عدم وجود جفت‌باز در بازهای مجاور با ساختار ‎$‎S‎$‎‏‎‏ می‌باشد‏، یعنی ‏در صورتی که ‎$‎a‎$‎‏‎‏ و ‎$‎b‎$‎‏‎ با یکدیگر تشکیل یک جفت‎‏ بدهند متغییر ‎$‎N‎$‎‏‏ صحیح خواهد بود و مقدار ‎$‎T‎$‎‏‏ را خواهد گرفت و در غیر این صورت غلط بوده مقدار آن برابر با ‎$‎F‎$‎‏‏ می‌گردد‏.‎‎ برای مثال مقدار تابع تفکیک کل ساختار هدف که در اندیس گذاری قبلی به صورت ‎$‎Z^{[x]}_‎S‎‎$‎‏‏ بود‎‏‏، در اندیس گذاری جدید به صورت $Z^{[‎\varnothing‎,\varnothing]}_{F,S}$ خواهد شد. با توجه به اینکه ساختار تهی بدون وابستگی به اینکه موقعیت‌های مجاور آن تشکیل جفت باز داده باشند یا نه‏، انرژی برابر با صفر دارد‏، خواهیم داشت‏: </p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\begin{eqnarray}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">Z^{[a,b]}_{T,E}=Z^{[a,b]}_{F,E}=e^{-0/RT}‎=1</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{eqnarray}‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏تابع بازگشت عمومی این الگوریتم با توجه به وضعیت اولین موقعیت ساختار آن دارای سه حالت می‌باشد:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\begin{itemize}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\item‎‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">اولین موقعیت یک باز آزاد باشد‎‎‏:‎ در این حالت اولین موقعیت ساختار ‎$‎S‎$‎‏‎‏ یک باز آزاد خواهد بود که با ‎‎$‎&quot;.&quot;‎$‎‏‎‏ نمایش داده می‌شود و بقیه موقعیت‌ها هر ساختاری مانند ‎$‎S'‎$‎‏‎‏ را می‌توانند داشته باشند‎$(‎S=&quot;.S'&quot;)‎$‎‏‎.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‏‎‎\begin{eqnarray}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">Z^{[a,b]}_{T,.S'}=Z^{[a,b]}_{F,.S'}=\sum_{a'\in ‎\beta‎}x^{\# gc(a')}.Z^{[a',b]}_{F,S'}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\label{eq:8}‎‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{eqnarray}‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\item‎‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏اولین موقعیت با آخرین موقعیت جفت باز تشکیل دهد ‎$‎(S=&quot;(S')&quot;)‎$‎‏‎‏‏، که این جفت‌باز تشکیل پشته با جفت باز ‎$‎a-b‎$‎‏‎ داده است.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\begin{eqnarray}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">Z^{[a,b]}_{T,(S')}=\sum_{a',b'\in ‎\beta‎^2}x^{gc(a',b')}.e^{‎\frac{-E^‎{\beta‎}_{ab\to a'b'}}{RT}‎}.Z^{[a',b']}_{T,S'}‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\label{eq:9}‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{eqnarray}‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\item‎‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">اولین موقعیت ساختار ‎$‎S‎$‎‏‎ تشکیل یک جفت‌باز دهد ولی این جفت‌باز یک‎ پشته با جفت باز ‎$‎a-b‎$‎‏‎‏ تشکیل نداده باشد ‎$‎(S=&quot;(S')S''&quot;)‎$‎‏‏، در این صورت یا بازهای ‎$‎a‎$‎‏‏ و‎‎ ‎$‎b‎$‎‏‎‏ با یکدیگر تشکیل جفت باز نداده‌اند‎ ‎‎یا ‏ساختار ‎$‎S''‎$‎‏‎ ‏تهی نخواهد بود و موقعیت اول با ‏موقعیتی غیر از موقعیت آخر تشکیل جفت داده است ‎‎\lr{(‎$‎N=F‎$‎‏ ‎Or ‎‎$‎S''‎\neq \varnothing ‎‎$‎‏)}‎‏که‎ خواهیم دا‎‏شت:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\begin{eqnarray}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">Z^{[a,b]}_{T,(S')S''}=\sum_{a',b'\in \beta^2}x^{\# gc(a',b')}.e^{‎\frac{-E^‎\beta‎_{\varnothing \to a'b'}}{RT}‎}.Z^{[a',b']}_{T,S'}.Z^{[b',b]}_{F,‎S''‎}‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\label{eq:10}‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{eqnarray}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{itemize}‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">پس از ‏اتمام این مرحله مقدار تابع تفکیک تصادفی برای کل ساختار بدست خواهد آمد. با توجه به نوع تابع تفکیک تعریف شده‏، ترکیب مقادیر ‎‎$‎a‎$‎‏‎‏‏، ‎$‎b‎$‎‏‎‏ و ‎$‎N‎$‎‏‎‏ به مقدار ثابتی محدود می‌گردد‏، یعنی پیچیدگی محاسباتی این الگوریتم پویا تنها به تعداد فراخوانی‌های بازگشتی وابسته می‌باشد و با توجه به اینکه این فراخوانی‌ها به تعداد ‎$‎|S|‎$‎‏‎‏ انجام می‌گیرد‏، پیچیدگی زمانی این مرحله از الگوریتم ‎‎‎$‎‎\theta‎‎(n)‎$‎‎‎‏ می‌باشد.‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\subsubsection*{‎‏بازگشت ‎‏به عقب تصادفی‎}‎‎</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">پس از آنکه تابع تفکیک به طور کامل محاسبه و ذخیره گردید‏، یک مرحله بازگشت به عقب تصادفی‏‎‎\footnote{‎‎\lr{Stochastic Backtrack}}‎ برای مقدار دهی به جفت‌بازهای توالی اجرا می‌گردد. ‏تفاوت بازگشت به عقب تصادفی با الگوریتم استاندارد بازگشت به عقب در این است که در بازگشت به عقب تصادفی در هر مرحله صرفا بهترین مسیر انتخاب نمی‌شود انتخاب به صورت تصادفی می‌باشد‏، به طوری که احتمال انتخاب یک مسیر به نسبت بهتر بودن عدد آن می‌باشد. یعنی در الگوریتم بازگشت به عقب تصادفی در هر مرحله بهترین مسیر بیشترین احتمال انتخاب شدن را دارا خواهد بود ولی مانند بازگشت به عقب استاندارد به طور قطعی انتخاب نخواهد شد. برای این منظور تابع ارائه شده در الگوریتم ‎\ref{alg:3}‎ به صورت ‎$‎SB_x(\varnothing,\varnothing,F,S^*)‎$‎‏‎‏ فراخوانی خواهد شد. ‏در این فراخوانی ‎‎$‎S^*‎$‎‏ ‏کل ساختار هدف خواهد بود و با توجه به اینکه ساختار هدف قبل و بعد از خود باز مجاور نخواهد داش‎‏ت‏، مقادیر ‎$‎a‎$‎‏ ‏و ‎$‎b‎$‎‏‏ به صورت تهی فراخوانی شده‌اند و مقدار ‎$‎F‎$‎‏‎ ‎نیز نشان دهنده عدم وجود جفت باز در مجاورت ساختار ‎$‎S^*‎$‎‏‏ می‌باشد‎‎. ‏در هر مرحله از این تابع یک مقدار دهی برای یکی یا بیش از یکی از موقعیت‌های ساختار هدف به صورت تصادفی و به نسبت احتمال محاسبه شده ‏توسط ‎‏فرمول ‎‎\ref{eq:5}‎‎ انجام می‌گیرد که شرایط مختلف این مقدار دهی در شکل ‎\ref{fig:39}‎ به نمایش درآمده است.‎‏ در این شکل ساختار ‎$‎S‎$‎‏‎‏ ساختار ورودی تابع ارائه شده در الگوریتم ‎‎\ref{alg:3} ‎‏می‎باشد‎ که باتوجه به وضعیت اولین باز آن و بازهای مجاور ساختار‏، در هر مرحله از بازگشت به عقب تصادفی یک یا دو باز از توالی مقدار دهی خواهند شد و برای هر حالت فرمول محاسبه احتمال این انتخاب به ازای هر ‎$‎a'‎$‎‏ ‏و ‎‎‎$‎b'‎$‎‏ ‎‏ممکن(‎$a'$ و $b'‎$‎‏ می‌توانند مقادیر ‎‎$‎A‎$‎‏‎‏‏، ‎$‎C‎$‎‏‎‏‏، ‎$‎G‎$‎‏‎‏ و ‎$‎U‎$‎‏‎‏ را داشته باشند) برای این بازها به نمایش درآمده است. همچنین ‎$‎S'‎$‎‏‎‏ و ‎$‎S''‎$‎‏‎‏ ساختارهایی می‌باشند که هنوز برای آنها باز انتخاب نشده است و الگوریتم به صورت بازگشتی تابع بازگشت به عقب تصادفی را برای این ساختارها فراخوانی می‌کند.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\vspace*{0.2cm}‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\begin{spacing}{0.8}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\begin{algorithm} ‎[t]‎   </p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\caption{تابع بازگشت به عقب تصادفی الگوریتم ‎\lr{IncaRNAtion}‎.}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\label{alg:3} ‎</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\begin{latin}</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\begin{algorithmic} </p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\Function {‎$‎SB_x‎$‎‏}{a,b,N,S} \\‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\textbf{begin}‎‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">	\State ‎$‎r \gets Random[0,Z^{[a,b]}_{N,S}]‎$ ‎‎\textit{\% a random real number between 0 and partition function of ‏‎S‎}‎‎‏</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">	\If {‎$‎S=‎‎\epsilon‎$‎‏}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">			\State return ‎$‎‎\epsilon‎‎$‎‏;</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">	\ElsIf {‎$‎S=.S'‎$‎‏}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">			\For {‎$‎a' \in ‎\mathcal{B}‎‎$‎‏}‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">				\State ‎$‎r ‎\gets r-‎x^{\# gc(a')}.‎Z^{[a',b]}_{F,S'}‎$‎‏‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">				\If{‎$‎r&lt;0‎$‎‏}‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">					\State return ‎$‎a'.SB_x(a',b,F,S')‎$‎‏‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">				\EndIf</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">			\EndFor‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">	\ElsIf {$S=(S')$}‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">		\For {$(a',b') \in ‎‎\mathcal{B}^2‎‎$‎‏‎‎}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">				\State $r \gets r-x^{\# gc(a',b')}.e^{-E^{‎\beta‎}_{ab\to a'b'}}.Z^{[a',b']}_{T,S'}$</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">				\If{$r&lt;0$}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">					\State return $a'.SB_x(a',b',T,S').b'$</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">				\EndIf</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">			\EndFor‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">	\Else {$S=(S')$}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">		\For {$(a',b') \in \mathcal{B}^2 $}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">				\State $r \gets r-x^{\# gc(a',b')}.e^{-E^{\beta}_{\varnothing\to a'b'}}.Z^{[a',b']}_{F,S'}.Z^{[b',b]}_{T,S''}$</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">				\If{$r&lt;0$}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">					\State return $a'.SB_x(a',b',T,S').b'.SB_x(b',b,F,S'')$</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">				\EndIf</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">			\EndFor</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">	\EndIf</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\EndFunction</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{algorithmic}‎</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{latin}‎</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{algorithm}‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{spacing}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\begin{figure}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\centering</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">{\footnotesize</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\includegraphics[height=7.5cm, width=15.5cm]{39}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\caption{شرایط مختلف مقداردهی الگوریتم \lr{IncaRNAtion}.}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\label{fig:39}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{figure} ‎</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏در‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎ این الگوریتم با توجه به ساختار ‎$‎S‎$‎‏‏ ‎که‎ یکی از سه حالت گفته شده را دارا خواهد بود‏، یکی از قسمت‌های الگوریتم انتخاب خواهد شد. برای مثال وقتی اولین موقعیت ساختار ‎$‎S‎$‎‏‎‏ یک باز جفت نشده باشد قسمت اول الگوریتم انتخاب شده و با توجه به تابع تفکیک ذخیره شده در قسمت قبل تمامی حالات ممکن برای ‎$‎a'‎$‎‏‎‏ در نظر گرفته می‌شود و یکی از آنها به برازندگی مقدار انرژی محاسبه شده در تابع تفکیک به تصادف انتخاب خواهد شد. پس از آن در عبارت ‎$a'.SB_x(a',b,F,S')$‎‎ موقعیت ‎$‎a'‎$‎‏‎‏ مقدار دهی شده و تابع با شرایطی که ‎$‎a'‎$‎‏‎‏ و ‎$‎b‎$‎‏‎‏ موقعیت‌های مجاور ساختار جدید می‌باشند‏، برای مقدار دهی بقیه موقعیت‌های ‎$‎S'‎$‎‏‎‏ فراخوانی خواهد شد. همچنین با توجه به باز آزاد بودن $a'$ این ساختار با جفت بازی احاطه نشده است پارامتر سوم الگوریتم به صورت $F$ فراخوانی میگردد. قسمت‌های دیگر الگوریتم نیز به صورت مشابه عمل کرده و موقعیت‌های ممکن را به صورت تصادفی غیر یکنواخت مقدار دهی کرده و الگوریتم را برای ساختار باقیمانده به صورت بازگشتی فراخوانی می‌کند.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏با توجه به اینکه در هر مرحله از فراخوانی این تابع حداقل یک موقعیت که از قبل مقداردهی نشده بود‏، مقدار داده می‌شود. بنابراین تعداد فراخوانی‌های تابع حداکثر ‎$‎|S|‎$‎‏‎‏ خواهد بود و با توجه به اینکه حلقه‌های این تابع با یک مقدار ثابت محدود می‌شوند‏، پیچیدگی محاسباتی این مرحله نیز ‎$‎‎\theta‎(n)‎$‎‏‎‏ می‌باشد.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\subsubsection*‎‏{روش ‎‎‏نمونه ‌سازی خود تطبیقی}‎‎</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">همانطور که اشاره شد هدف اصلی الگوریتم ارائه شده توسط راینهارز و همکاران‎\cite{rein}‎‏ ساخت مجموعه‌ای از توالی‌هاست که مقدار ‎$‎C-G‎$‎‏‎‏ آنها متناسب با یک مقدار از پیش تعیین شده باشد. با توجه به اینکه مقدار دهی دقیق بسیار مشکل می‌باشد(برای مثال وقتی تعداد جفت‌بازهای یک ساختار ورودی ‎فرد‎‏‎‏ باشد نمی‌توان به طور دقیق $\%50$ مقدار ‎$‎C-G‎$‎‏‎‏ داشت)‏، وجود یک مقدار خطا یا تلورانس قابل قبول می‌باشد که به عنوان پارامتر ورودی از کاربر دریافت می‌شود و با ‎$k‎$‎‏‏ ‎نمایش‎ داده خواهد شد. یعنی مقدار ‎$‎C-G‎$‎‏‎‏ جواب‌های نهایی باید در بازه ‎$‎[gc-k,gc+k]‎$‎‏‎‏ قرار گیرد.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">همانطور که در شکل ‎\ref{fig:310}‎ قابل مشاهده می‌باشد‏، این روش خود تطبیقی در ابتدا مقدار پارامتر ‎$‎x‎$‎‏‎‏ را برابر یک قرار می‌دهد‏، این پارامتر می‌تواند یک مقدار حقیقی بین صفر تا بینهایت را داشته باشد و انتظار مقدار $C-G$ توالی‌ها رابطه مستقیم با اندازه پارامتر $x$ دارد. به طوری که اگر $x$ برابر صفر باشد، امید ریاضی مقدار $C-G$ نیز $\%0$ خواهد بود و برای $x \to + \infty$ این مقدار به $\%100$ میل می‌کند. سپس اجرای مرحله بازگشت به عقب به صورت پیاپی‏، مجموعه‌ای از توالی‌ها را می‌سازد و میانگین مقدار ‎$‎C-G‎$‎‏‎‏ بدست آمده توسط مقدار فعلی ‎$‎x‎$‎‏‎‏ را محاسبه می‌کند‏، سپس توالی‌هایی که در شرط مربوط به مقدار ‎$‎C-G‎$‎‏‎‏ مورد نیاز صدق می‌کنند نگاه داشته می‌شوند و در صورتی که تعداد آنها به مقدار کافی نرسیده بود‏، مقدار ‎$‎x‎$‎‏‎‏ بر اساس میانگین مقدار ‎‎$‎C-G‎$‎‏ ‎‏بدست‎ آمده‏، کم یا زیاد می‌گردد و قسمت بازگشت به عقب با مقدار جدید پارامتر ‎$‎x‎$‎‏‏‎ تکرار می‌شود. </p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\begin{figure}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\centering</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">{\footnotesize</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\includegraphics[height=8.5cm, width=7.5cm]{310}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\caption{‎‎‏مرحله نمونه‌سازی خود تطبیقی الگوریتم ‎\lr{IncaRNAtion}‎.}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\label{fig:310}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{figure}‎‏‎</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\subsubsection*{‎‏پردازش ‎‎‏نهایی بازهای آزاد}‎</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">با توجه به اینکه بازهای آزاد تاثیری روی مقدار ‎$‎C-G‎$‎‏‎‏ ندارند و همچنین مدل ساده شده محاسبه انرژی بکار رفته توسط راینهارز و همکاران‎\cite{rein}‎‏ بازهای آزاد را در نظر نمی‌گیرد‏، آنها پس از ساخت نمونه‌هایی با جفت‌بازهای مناسب در یک مرحله پردازش نهایی از روش ‎\lr{‎RNAInverse‎‏}(رجوع شود به بخش $2$.‎$‎2‎$‎‏.$2$)‏  ‎‎استفاده کردند تا مقادیر بازهای آزاد را به صورت مناسب بدست آورند‏، همانطور که در معرفی الگوریتم ‎\lr{RNAInverse}‎‏ اشاره شد‏، در هنگام استفاده از این الگوریتم می‌توان تعیین نمود که جهش‌ها تنها بر روی موقعیت‌های صحیح جفت نشده صورت گیرد.‎   راینهارز و همکاران\cite{rein} با استفاده از این موضوع از تغییر ‏چشمگیر روی مقدار ‎$‎C-G‎$‎‎‎‎‎‎‎‎‎‏‎‎‏ نهایی جلوگیری نمودند.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‎\subsubsection*{‎‏الگوریتم}‎‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">به طور کلی اگر بخواهیم عملکرد الگوریتم ‎‏‎\lr{IncaRNAtion}‎ را مرحله به مرحله توضیح دهیم به صورت زیر خواهد بود.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\begin{enumerate}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\item</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">در ابتدا با استفاده از ‎‏فرمول‌های ‎‎\ref{eq:8}‎‎‏‏، ‎‎\ref{eq:9‏}‎ و ‎‎\ref{eq:10}‎‎‎‏ مقادیر ‎$‎Z^{[a,b]}_{N,S}‎$‎‏‎‏ برای ساختار هدف و زیر ساختارهای آن محاسبه می‌گردد.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\item</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">در مرحله دوم با استفاده از تابع بازگشت به عقب تصادفی ‏ارائه شده در الگوریتم ‎‎\ref{alg:3}‎‎ یک توالی برای ساختار هدف مقدار دهی می‌شود.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\item</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">در این مرحله ‏به صورتی که در شکل ‎‎\ref{fig:310}‎‎ ارائه شده است‏، تابع بازگشت به عقب تصادفی بارها تکرار شده و میانگین مقدار ‎$‎C-G‎$‎‏‎‏ توالی‌های بدست آمده محاسبه می‌گردد. مقدار پارامتر ‎$‎x‎$‎‏‎ ‏با توجه به این میانگین دوباره تنظیم می‌شود. توالی‌هایی که مقدار ‎$‎C-G‎$‎‏‎‏ آنها مناسب بوده ذخیره شده و اگر تعداد این توالی‌ها کافی نبود مرحله بازگشت به عقب با مقدار جدید ‎$‎x‎$‎‏‎‏ دوباره انجام می‌گیرد.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\item</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;"> در مرحله پایانی نیز الگریتم ‎\lr{RNAinverse}‎‏ برای مقدار دهی به بازهای آزاد توالی‌های ساخته شده روی آنها اعمال می‌گردد.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{enumerate}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\subsection{‏نتایج ‎‎‏بدست آمده توسط الگوریتم ‎\lr{IncaRNAtion}‎}‎‎‏‎</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">راینهارز و همکاران‎\cite{rein}‎‏ برای بررسی عملکرد الگوریتم خود از پایگاه داده انتخاب شده توسط لوین‎\cite{global}‎‎‎‏ که شامل 50 ساختار با طول بین 20 تا 100 نوکلئوتید از گونه‌های مختلفی در پایگاه داده ‎\lr{RNA ‎Strand}‎‏‎‎‏ بود‏، استفاده کردند. برای آشنایی بیشتر با این داده‌ها ساختارها با توجه سه ویژگی طول‏ ساختار‏، فشردگی پشته‌ها و درصد بازهای آزاد گروه بندی شده‌اند که نتایج این گروه بندی در شکل ‎‎\ref{fig:316}‎‎ به نمایش درآمده است. محور افقی نمودارهای ارائه شده مربوط به هر ویژگی می‌باشد و محور عمودی آن تعداد اعضای متعلق به هر گروه.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\begin{figure}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\centering</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">{\footnotesize</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\includegraphics[height=4.5cm, width=15cm]{316}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\caption{‎‎‏ویژگی‌های ساختارهای استفاده شده برای بررسی عملکرد الگوریتم ‎\lr{IncaRNAtion}‎‏.}‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\label{fig:316}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{figure}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏در شکل ‎‎\ref{fig:311}‎‎ مقدار ‎$‎C-G‎$‎‏‎‏ بدست آمده توسط روش‌های قبلی حل مسئله پیش‌بینی‎‏ پیچش معکوس ‎\lr{RNA}‎‏ بدست آمده است‏، همانطور که مشاهده می‌شود هیچ‌ کدام از این روش‌ها موفق به تولید توالی‌ها‎‏یی با مقدار ‎$‎C-G‎$‎‏‎ پایین (‎$‎&lt;\%30‎$‎‏‎‏) نشده‌اند‏. این موضوع یک دلیل برای نیاز به وجود الگوریتم‎‎  \lr{IncaRNAtion}‏ با توانایی تنظیم مقدار ‎$‎C-G‎$‎‏‎‏ می‌باشد.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\begin{figure}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\centering</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">{\footnotesize</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\includegraphics[height=8.5cm, width=11cm]{311}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\caption{‎‏مقدار ‎$‎C-G‎$‎‏‏ بدست آمده با روش‌های پیشین.‎}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\label{fig:311}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{figure}</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏راینهارز و همکاران‎\cite{rein}‎‏ برای بررسی عملکرد روش خود درصد موفقیت را میزان توالی‌هایی که وقتی انرژی آنها را با قوانین‎ ترمودینامیکی موجود محاسبه کنیم‏، ساختار با حداقل انرژی بدست آمده آنها با استفاده از بسته وینا‎‎\footnote{\lr{http://www.tbi.univie.ac.at/~ivo/RNA/.}}‎‎ ‎‎\cite{vienna}‎‎ با ساختار هدف یکی ‎‏باشد در نظر گرفتند. نتایج این بررسی در شکل ‎\ref{fig:312}‎ به نمایش درآمده است. در این شکل درصد موفقیت اجراهای الگوریتم ‎\lr{IncaRNAtion}‎ با مقادیر ‎مختلف ‎ ‎‎10 الی 90 درصد مقدار ‎$‎C-G‎$‎‏‎‏‏، ‏براساس ویژگی‌های ساختارهای هدف به نمایش درآمده است. بطوریکه محور عمودی این شکل‌ها درصد موفقیت و محور افقی آنها به ترتیب از چپ به راست طول ساختار، فشردگی پشته‌ها و درصد بازهای آزاد می‌باشد. همچنین نمودارهای قسمت بالایی مربوط به الگوریتم بدون پردازش نهایی(استفاده از الگوریتم \lr{RNAInverse}) و قسمت پایینی مربوط به نتایج الگوریتم پس از اجرای پردازش نهایی ‎‏می‌باشد. همانطور که در این شکل قابل مشاهده می‌باشد‏، میزان این موفقیت پیش از پردازش نهایی بسیار پایین می‌باشد که دلیل این موضوع نبود یک شرط توقف در مورد ساختار با حداقل انرژی پیش از فاز پردازش نهایی است. پس از استفاده از جستجوی محلی برای پردازش نهایی پیشرفت قابل ملاحظه‌ای در درصد موفقیت الگوریم وجود دارد. درصد موفقیت با میزان طول توالی‌ها و درصد بازهای آزاد نسبت عکس دارد‏، به طوری که با افزایش آنها موفقیت کاهش می‌باید. اما این نسبت برای فشردگی پشته‌ها در ساختارهای   هدف به صورت مستقیم می‌باشد یعنی هرچه در ساختار هدف فشردگی پشته‌ای بیشتر باشد احتمال موفقیت الگوریتم ‎\lr{IncaRNAtion}‎‏ بیشتر خواهد بود. همچنین با توجه به اینکه در شکل ‎\ref{fig:312}‎ شیب خطوط در نمودارهای مربوط به طول ساختارها کمتر از شیب آنها در دو نمودار دیگر می‌یاشد‏، می‌توان فهمید که طول ‎\lr{RNA}‎‏ تاثیر چندانی در سختی یک ورودی برای این الگوریتم ندارد و سختی طراحی یک توالی برای یک ساختار توسط الگوریتم ‎\lr{IncaRNAtion}‎‏ بیشتر وابسته به درصد نوکلئوتیدهای آزاد آن ساختار می‌باشد و همچنین در این نتایج می‌توان دید که خط مربوط به ‎$‎10\% ‎C-G‎$‎‏‎‏ پایین‌ترین خط در تمام نمودارها است و همچنین خطوط مربوط به $90\% C-G$ و $70\% C-G$  در همه حالات بالاترین مقادیر موفقیت را نشان داده‌اند‏، به طور کلی هرچه مقدار ‎$‎C-G‎$‎‏‎‏ بیشتر شده درصد موفقیت نیز افزایش یافته است‏، با توجه به این موضوع می‌توان گفت که ایجاد توالی‌هایی با درصد کم مقدار ‎$‎C-G‎$‎‏‏‎‎ برای انواع مختلف ساختارهای هدف یک مسئله چالش برانگیز می‌باشد.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\begin{figure}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\centering</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">{\footnotesize</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\includegraphics[height=7cm, width=15.5cm]{312}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\caption{درصد موفقیت الگوریتم ‎\lr{IncaRNAtion}‎.}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\label{fig:312}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{figure}</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎‏‎\subsubsection*{‎‏مقایسه ‎‏نتایج ‎\lr{IncaRNAtion} ‏و ‎\lr{RNA-SSD}‎‎‎}‎‎‎‏‎</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">راینهارز‎ و همکاران‎\cite{rein}‎‏ برای مقایسه نتایج بدست آمده الگوریتم خود با روش‌هایی که از طریق جستجوی محلی اقدام به حل مسئله پیش‌بینی  پیچش معکوس ‎\lr{RNA}‎‏ نمودند‏، الگوریتم ‎\lr{RNA-SSD}‎‏ را برای این مقایسه انتخاب نمودند. همچنین آنها الگوریتم خود را به دو روش بدون پردازش نهایی و با پردازش نهایی اجرا کرده و برای هر ساختار هدف در هر بار اجرا تنها یک نمونه را ساختند تا نوع خروجی الگوریتم آنها نیز مانند خروجی روش‌های مبتنی بر جستجوی محلی گردد. در شکل ‎‎\ref{fig:313}‎‎ زمان اجرای الگوریتم‌ها مقایسه شده است که همانطور که قابل مشاهده می‌باشد طبق پیش‌بینی زمان اجرای الگوریتم ‎\lr{IncaRNAtion}‎‏‎ با طول ساختار هدف رابطه خطی دارد و با افزایش طول عملکرد بهتری را نسبت به روش ‎\lr{RNA-SSD}‎‏ نشان داده است.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\begin{figure}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\centering</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">{\footnotesize</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\includegraphics[height=8.5cm, width=11cm]{313}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\caption{مقایسه زمان اجرای الگوریتم‌های‎ \lr{IncaRNAtion} و ‎\lr{RNA-SSD}‎.}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\label{fig:313}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎}‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{figure}‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">راینهارز و همکاران\cite{rein} در مقاله خود به این موضوع اشاره کرده‌اند که وقتی از قوانین ترمودینامیکی برای محاسبه درصد موفقیت استفاده شود‎‎‏‏، روش آنها پیشرفتی را نسبت به روش‌های جستجوی محلی نشان نمی‌دهد‏، از این رو به مقایسه درصد موفقیت روش خود با روش‌های قبلی نپرداختند و تنها  در کنار مقایسه زمان اجرای الگوریتم خود با روش ‎\lr{RNA-‎SSD}‎‎‏ به بررسی تنوع توالی‎‎\footnote{\lr{Sequence Diversity‏ }}‎‎ تولید شده توسط این‏ دو روش برای توالی‌هایی با مقدار ‎‎$‎C-G‎$‎‏ پایین ‎‎پرداختند. نتایج بدست آمده توسط این دو الگوریتم برای توالی‌هایی با مقدار ‎$‎C-G‎$‎‏‎‏  برابر با ‎$‎10\%‎$‎‏‎‏ و ‎$‎30\%‎$‎‏‎‏ در شکل ‎‎\ref{fig:317}‎‎ به تصویر کشیده شده است. با اینکه نتایج بسیار نزدیک به یکدیگر می‌باشند اما عملکرد الگوریتم ‎\lr{IncaRNAtion+‎RNAInverse‎}‎‏ برای مقدار ‎$‎C-G‎$‎‏‎‏ پایین تاحدی بهتر است. به طوری که خط مربوط به‏ این الگوریتم در هر سه نمودار مربوط به ‎‎$‎10\%CG‎$‎‏‎‏ پایین‌تر از خطوط دیگر بوده‏ است. یعنی توالی تولید شده توسط این الگوریتم در زیر توالی‌های خود شباهت‌های کمتری را نشان داده است و تنوع بیشتری دارد. اما این برتری با افزایش مقدار ‎$‎C-G‎$‎‏‎‏ به ‎$‎30\%‎$‎‏‏، ‎‏کاسته‎ شده است. به طوری که خط مربوط به الگوریتم ‏‎\lr{RNA-SSD}‎ در مواقعی پایین ترین خط موجود در نمودار می‌باشد.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\begin{figure}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\centering</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">{\footnotesize</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\includegraphics[height=10cm, width=15cm]{317}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\caption{مقایسه ‎‏تنوع ‏توالی‌های‎ ‎توالی‌‎ الگوریتم‌های \lr{IncaRNAtion} و \lr{RNA-SSD}.}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\label{fig:317}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">}</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">\end{figure}</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎\section{‎‏جمع‌بندی}‎</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‎</p>
<p dir='rtl' style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:0;">‏در این فصل به ارائه دو مورد از الگوریتم‌هایی که برای حل مسئله پیش‌بینی  پیچش معکوس  ‎\lr{RNA}‎‏ وجود دارند‏، پرداخته شد. در ابتدا الگوریتم ‎\lr{NUPACK}‎‏ معرفی گردید و به ارائه نتایج آن پرداخته شده است. الگوریتم ‎\lr{NUPACK}‎‏ با توجه نوع شکستن ساختاری خاص خود و همچنین استفاده از تابع تفکیک به عنوان تابع هدف جستجو‏، یکی از الگوریتم‌های شاخصی است که با استفاده از روش جستجوی محلی اقدام به حل  مسئله پیش‌بینی پیچش معکوس  \lr{RNA} می‌کند. در بخش دوم این فصل نیز الگوریتم ‎\lr{IncaRNAtion}‎‏ معرفی گردید که شاخصه اصلی این الگوریتم قابلیت تنظیم مقدار ‎$‎C-G‎$‎‏‎‏ توسط کاربر می‌باشد که با توجه به این خاصیت این الگوریتم نیز جزو روش‌های کاربردی و شاخص برای حل  مسئله پیش‌بینی پیچش معکوس  \lr{RNA}  قرار می‌گیرد.</p></body></html>